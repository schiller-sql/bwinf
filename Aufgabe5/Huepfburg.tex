\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten vier Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 5: Hüpfburg}        % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeamId}{00919}                       % Team-ID aus dem PMS angeben
\newcommand{\TeamName}{Object Grind}              % Team-Namen angeben
\newcommand{\Namen}{Lennart Protte}               % Namen der Bearbeiter/-innen dieser Aufgabe angeben

% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Team-ID: \TeamId}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

%Für Überschriften
\usepackage[labelformat=empty]{caption}
\captionsetup[algorithm]{labelformat=empty}

% Für Algorithmen
\usepackage{algpseudocode}
\usepackage{adigraph}
\usepackage{algorithm}
\usepackage{algorithmicx}


% Für Quelltext
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
    keywordstyle=\color{blue},commentstyle=\color{mygreen},
    stringstyle=\color{mymauve},rulecolor=\color{black},
    basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
    captionpos=b, % sets the caption-position to bottom
    keepspaces=true, % keeps spaces in text
    numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
    showtabs=false, stepnumber=2, tabsize=2, title=\lstname ,
    inputencoding = utf8,  % Input encoding
    extendedchars = true,  % Extended ASCII
    literate      =        % Support additional characters
        {á}{{\'a}}1  {é}{{\'e}}1  {í}{{\'i}}1 {ó}{{\'o}}1  {ú}{{\'u}}1
        {Á}{{\'A}}1  {É}{{\'E}}1  {Í}{{\'I}}1 {Ó}{{\'O}}1  {Ú}{{\'U}}1
        {à}{{\`a}}1  {è}{{\`e}}1  {ì}{{\`i}}1 {ò}{{\`o}}1  {ù}{{\`u}}1
        {À}{{\`A}}1  {È}{{\'E}}1  {Ì}{{\`I}}1 {Ò}{{\`O}}1  {Ù}{{\`U}}1
        {ä}{{\"a}}1  {ë}{{\"e}}1  {ï}{{\"i}}1 {ö}{{\"o}}1  {ü}{{\"u}}1
        {Ä}{{\"A}}1  {Ë}{{\"E}}1  {Ï}{{\"I}}1 {Ö}{{\"O}}1  {Ü}{{\"U}}1
        {â}{{\^a}}1  {ê}{{\^e}}1  {î}{{\^i}}1 {ô}{{\^o}}1  {û}{{\^u}}1
        {Â}{{\^A}}1  {Ê}{{\^E}}1  {Î}{{\^I}}1 {Ô}{{\^O}}1  {Û}{{\^U}}1
        {œ}{{\oe}}1  {Œ}{{\OE}}1  {æ}{{\ae}}1 {Æ}{{\AE}}1  {ß}{{\ss}}1
        {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1  {Ø}{{\O}}1   {å}{{\r a}}1
        {Å}{{\r A}}1 {ã}{{\~a}}1  {õ}{{\~o}}1 {Ã}{{\~A}}1  {Õ}{{\~O}}1
        {ñ}{{\~n}}1  {Ñ}{{\~N}}1  {¿}{{?`}}1  {¡}{{!`}}1
        {°}{{\textdegree}}1 {º}{{\textordmasculine}}1 {ª}{{\textordfeminine}}1
}
\lstdefinelanguage{JavaScript}{ % JavaScript ist als einzige Sprache noch nicht vordefiniert
    keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with},
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]',
    morestring=[b]",
    sensitive=true
}

% Diese beiden Pakete müssen zuletzt geladen werden
\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Team-ID: \LARGE \TeamId \\\\
\LARGE Team-Name: \LARGE \TeamName \\\\
\LARGE Bearbeiter/-innen dieser Aufgabe: \\
\LARGE \Namen\\\\}
\date{\LARGE\today}

\begin{document}

    \maketitle
    \tableofcontents

    \vspace{0.5cm}


    \section{Lösungsidee}\label{sec:losungsidee}
    
    Der Aufgabenstellung zu entnehmen ist,
    dass sich beide Spieler immer genau gleichzeitig um genau einen Punkt entlang der Pfeilrichtung bewegen
    und der Parcours als absolviert gilt,
    wenn sich beide gleichzeitig auf den gleichen Punkt bewegen.
    Dabei ist die Startposition der Spieler jeweils immer identisch.

    Als Datenstruktur für den Parcours eignet sich ein gerichteter und ungewichteter Graph.
    Die Pfeile zwischen den Kästchen werden durch gerichtete Kanten repräsentiert,
    während die Knoten repräsentativ für die Felder stehen.

    Die abstrahierte Problemstellung der Aufgabe ist es,
    für jeden der zwei Ausgangspunkte jeweils einen Weg zu einem Knoten in einem gerichteten und ungewichteten Graphen zu finden.
    Dieser muss von beiden Ausgangsknoten mit der gleichen Anzahl an Schritten zu erreichen sein.
    Dabei darf die Schrittfolge nie entgegengesetzt zur Kantenrichtung verlaufen.

    Dies kann erreicht werden,
    indem für beide Spieler eine Breitensuche parallel schrittweise durchgeführt wird.
    Davon ausgehend, dass es dabei zu einem gemeinsamen Schnittpunkt kommt,
    wird die Breitensuche fortgesetzt,
    bis sich mindestens ein Knoten aus der Schnittmenge der beiden Suchen ergibt.
    Wenn es sich um einen lösbaren Parcours handelt,
    wird für beide Spieler im selben Schritt mindestens ein gleicher Knoten gefunden.

    Sollte der Parcours nicht lösbar sein,
    wiederholen sich die Knotenmengen
    für beide Spieler ab demselben Zeitpunkt.
    So kommt es in \hyperref[fig:Figure1]{Figur 1}
    zu einer zeitgleichen Wiederholung der Knotenmenge bei beiden Spielern.

    \begin{figure}
        \centering
        \NewAdigraph{FigurEins}{
            1:0,0;
            2:2,0;
            3:1,1;
        }{
            1,2;
            2,3;
            3,1;
        }{}
        \FigurEins{}
        \caption{Figur 1: Nicht lösbarer zyklischer Parcours}
        \label{fig:Figure1}
    \end{figure}

    \begin{table}
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            0.               & \{ 1 \}                        & \{ 2 \}                        \\
            1.               & \{ 2 \}                        & \{ 3 \}                        \\
            2.               & \{ 3 \}                        & \{ 1 \}                        \\
            3.               & \{ 1 \}                        & \{ 2 \}                        \\
        \end{tabular}
        \caption{Tabelle 1: Schrittfolge für \hyperref[fig:Figure1]{Figur 1}}
        \label{tab:Table1}
    \end{table}

    In Schritt drei findet bei beiden Spielern eine Wiederholung zu Schritt 0 statt.
    Damit kann der Parcours sicher für ungültig erklärt
    und die Suche nach einem gemeinsamen Zielpunkt abgebrochen werden.
    Dies gilt, da sich beide Spieler in einem Zyklus befinden
    und im ersten Durchlauf des Zyklus kein gemeinsamer Punkt gefunden wurde.

    Der Parcours ist ebenfalls nicht lösbar, sollte eine der beiden oder beide Knotenmengen leer sein.
    Dies gilt, da im nächsten Schritt keine weiteren Knoten für die leere Knotenmenge erreichbar wären
    und somit für einen der beiden Spieler kein Schritt mehr möglich ist.
    Da die Aufgabenstellung allerdings vorgibt, dass sich in jedem Schritt beide Spieler bewegen müssen,
    ist der Parcours damit für ungültig zu erklären.
    So kommt es in \hyperref[fig:Figure2]{Figur 2} zu einer solchen Sackgasse für einen der Spieler.

    \begin{figure}[!h]
        \centering
        \NewAdigraph{FigurZwei}{
            1:0,0;
            2:4.5,0;
            3:1.5,0;
            4:3,0;
        }{
            1,3;
            3,4;
            2,4;
        }{}
        \FigurZwei{}
        \caption{Figur 2: Nicht lösbarer Parcours mit Sackgasse}
        \label{fig:Figure2}
    \end{figure}

    \begin{table}[!h]
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            0.               & \{ 1 \}                        & \{ 2 \}                        \\
            1.               & \{ 3 \}                        & \{ 4 \}                        \\
            2.               & \{ 4 \}                        & \{   \}                           \\
        \end{tabular}
        \caption{Tabelle 2: Schrittfolge für \hyperref[fig:Figure2]{Figur 2}}
        \label{tab:Table2}
    \end{table}

    Hier kommt es bereits im zweiten Schritt dazu, dass die Knotenmenge des zweiten Spielers leer ist.
    Damit ist es unmöglich,
    dass Spieler eins und Spieler zwei zum gleichen Zeitpunkt auf einen Knoten laufen können,
    da Spieler zwei keinen weiteren Schritt gehen kann
    und sie sich noch nicht auf dem gleichen Feld befinden.

    Im Algorithmus muss daher in jedem Schritt für beide Spieler in der Breitensuche überprüft werden,
    ob die aktuelle Menge der besuchten Knoten in der Breitensuche
    bereits in der Schrittfolge des jeweiligen Spielers enthalten ist.
    Dazu müssen die Schrittfolgen beider Spieler gespeichert werden.
    Des Weiteren muss überprüft werden, ob beide Spieler erreichbare Knoten haben.
    Sollte dies nicht der Fall sein, kann dieser Spieler sich nicht weiterbewegen
    und sollte noch kein Zielknoten gefunden sein, ist der Parcours damit ungültig.
    Ist einer dieser Bedingungen erfüllt, ist der Parcours nicht lösbar
    und die Suche nach einem gemeinsamen Feld kann abgebrochen werden.
    Sollten sich die beiden Knotenmengen zu einem gemeinsamen Zeitpunkt an mindestens einem Knoten überschneiden,
    kann der Parcours in diesem Schritt an diesem Schnittknoten von beiden Spielern gleichzeitig erreicht werden
    und ist somit lösbar.
    Ist keine der Bedingungen erfüllt,
    folgt ein weiterer Schritt der Breitensuche.

    Sobald der Zielpunkt gefunden ist,
    an dem sich die beide Schrittfolgen überschneiden,
    gilt es einen Weg von den Startknoten zu diesem Zielknoten zu finden.
    Gibt es mehrere Zielpunkte, kann ein beliebiger gewählt werden,
    da alle mit der gleichen Schrittanzahl beider Spieler erreicht werden können.

    Aus dem ermittelten Zielknoten, den gegebenen Startknoten und der generierten Schrittfolge von jedem Startknoten zum Zielknoten,
    lässt sich nun der Weg für jeden der Startknoten bestimmen.
    Der letzte Eintrag in den Schrittfolgen beinhaltet den Zielknoten,
    während der erste Eintrag den jeweiligen Startknoten enthält.

    \begin{algorithm}
        \begin{algorithmic}[1]
            \State $A = Anzahl_{Schritte}$
            \State $T = Zielknoten$
            \State $Weg_{Knotenfolge}$
            \State Füge $T$ zu $Weg$ an Stelle $A$ hinzu \label{lst:line:zeileVier}
            \For {$A > 0$}
                \State $A = A -1$
                \For {$K_{Knoten} = 1,2,\ldots,N$}
                    \If{$K$ $zeigt$ $auf$ $T$}
                        \label{lst:line:zeileAcht}
                        \State füge $K$ zu $Weg$ an Stelle $A$ hinzu \label{lst:line:zeileNeun}
                        \State $T = K$
                    \EndIf
                \EndFor
            \EndFor
        \end{algorithmic}
        \caption{Algorithmus 1: Wegsuche Algorithmus}
        \label{alg:Algorithm1}
    \end{algorithm}

    Wie im \hyperref[alg:Algorithm1]{Wegsuche Algorithmus} in Zeile~\ref{lst:line:zeileVier} dargestellt,
    kann zunächst im Weg der Zielknoten an letzter Stelle eingetragen werden.
    Es lässt sich nun in jeder Schrittfolge der vorletzte Schritt betrachten.
    In diesem Schritt kann nun ein Knoten ermittelt werden,
    welcher als Nachbar entlang der Kantenrichtung den Zielknoten besitzt (Zeile~\ref{lst:line:zeileAcht}).
    Ist dieser Knoten gefunden,
    kann er im Weg an der entsprechenden Stelle gespeichert werden (Zeile~\ref{lst:line:zeileNeun}).
    Dieses Verfahren wird nun solange für den nächsten Schritt und den zuletzt in den Weg eingefügten Knoten wiederholt,
    bis man am Startknoten angelangt ist.


    \section{Umsetzung}\label{sec:umsetzung}

    Eine Menge von Knoten wird als \texttt{BitSet} dargestellt.
    Ein \texttt{BitSet} in Java ist eine lineare statische Datenstruktur,
    welche Bits, die alle anhand eines Indexes gesetzt werden können,
    speichert.
    Die Länge jedes \texttt{BitSet} ist gleich der Anzahl der Knoten des Graphen
    und jeder Index steht dabei für einen Knoten.
    Steht an diesem Index im \texttt{BitSet} eine 1,
    ist der Knoten in der Knotenmenge enthalten,
    andernfalls ist er es nicht.
    Beispielsweise gilt $0101 \widehat{=} \{2, 4\}$.
    Da der erste Index eines \texttt{BitSet} 0 ist,
    korrespondiert der Index 0 zu Knoten eins des Parcours.

    Ein Graph wird als \texttt{BitSet[]} dargestellt.
    Jeder Index des Arrays korrespondiert zu einem Knoten.
    Das am Index eines Knoten enthaltene \texttt{BitSet} ist eine Knotenmenge.
    Diese stellt da, zu welchen Knoten eine Kante ausgeht.

    \begin{figure}[!h]
        \centering
        \NewAdigraph{FigurDrei}{
            1:0,0;
            2:1.5,0;
            3:0.75,1;
            4:2.5,1;
        }{
            1,2;
            2,3;
            2,4;
            1,3;
        }
        \FigurDrei{
            1,2,3::blue;
        }
        \caption{Figur 3: Graph der Matrix}

        \label{fig:Figure3}
    \end{figure}

    So kann beispielsweise \hyperref[fig:Figure3]{Figur 3} als das folgende \texttt{BitSet[]} dargestellt werden.

    \[
        \texttt{BitSet[]}_{Graph} = \begin{bmatrix}
                                        0 & \textcolor{blue}{1} & 1                   & 0 \\
                                        0 & 0                   & \textcolor{blue}{1} & 1 \\
                                        0 & 0                   & 0                   & 0 \\
                                        0 & 0                   & 0                   & 0 \\
        \end{bmatrix}
    \]

    Die Schrittfolge ist eine \texttt{List<BitSet>},
    d.h. eine \texttt{List} aus \texttt{BitSet}.
    Index 0 der \texttt{List} korrespondiert zum Ausgangspunkt,
    daher Schritt 0,  beziehungsweise zur Startposition.
    \[
        \texttt{List<BitSet>}_{Schrittfolge} = \left\lbrace
        \begin{tabular}{ll}
            \underline{\text{List Index:}} & \underline{\text{BitSet:}} \\
            0                              & \{ 1000 \}                 \\
            1                              & \{ 0100 \}                 \\
            2                              & \{ 0010 \}                 \\
        \end{tabular}
        \right\rbrace
    \]

    Ein Weg ist ein \texttt{int[]}.
    Dabei repräsentiert der Index 0 den Ausgangspunkt des Weges.
    Aufgrund der Tatsache,
    dass im Graphen der Index 0, dem Knoten eins entspricht,
    sind die Werte im Weg um eins niedriger eingetragen, als die tatsächlichen Knoten.
    Ist beispielsweise am Index zwei der Integer drei eingetragen,
    befindet sich an der dritten Position des Weges der Knoten vier.
    Dies wird in der Ausgabe berücksichtigt, wo zu jedem Wert eins addiert wird.

    In der Implementation wurde der Algorithmus in der Methode
    \texttt{int[][] sameTargetRoute(\ldots)} umgesetzt.
    Dort werden die Schrittfolgen in einer \texttt{do-while Schleife} schrittweise erweitert
    und auf die in \hyperref[sec:losungsidee]{der Lösungsidee} beschriebenen Bedingungen geprüft.
    Wenn in der Schleife ein Zielknoten gefunden wird, wird unter der verwendung der Hilfsmethode
    \texttt{int[] findSingleRouteInTimeline(\ldots)},
    welche im \hyperref[alg:Algorithm1]{Wegsuche Algorithmus} beschrieben ist,
    der Weg zwischen den Startknoten und dem Zielknoten ermittelt und das Erbegnis anschließend zurückgegeben.
    Des weiteren wird in der Schleife die Hilfsmethode
    \texttt{BitSet neighbourNodes(\ldots)},
    zur Ermittlung der Nachbarsknoten verwendet.
    Um auf die Wiederholungen der Schrittfolgen zu prüfen, wird außerdem die Methode
    \texttt{boolean timelineRepeats(\ldots)} aufgerufen.
    Zur Ermittlung der Schnittmenge der zwei Schrittfolgen wird
    \texttt{int firstSameTargetOfTimelines(\ldots)} benutzt.


    \section{Beispiele}\label{sec:beispiele}
        
        \begin{figure}[h!]
        \centering
        \NewAdigraph{FigurVier}{
            1:3,0;
            2:-3.5,-1;
            3:-1.5,0;
            4:4,0;
            5:0,3;
            6:-3.5,1;
            7:1.5,3;
            8:3.5,1.5;
            9:3,-1.5;
            10:0,0;
            11:0,-3;
            12:-1.5,1.5;
            13:0,1.5;
            14:1.5,0;
            15:-3,3;
            16:0,-1.5;
            17:2,-3;
            18:1.5,1.5;
            19:-2.5,-3;
            20:-1.5,-1.5;
        }{
            1,18:1;
            1,8;
            1,4;
            2,3;
            2,19:1;
            3,19;
            3,6;
            5,15;
            5,12;
            5,13;
            6,2;
            6,12;
            7,5;
            7,8;
            8,18;
            8,4;
            9,4;
            9,1;
            9,14;
            10,16;
            10,3;
            10,12;
            10,18;
            11,19;
            12,3;
            13,7;
            13,10:3;
            14,17;
            14,16;
            14,10;
            14,18;
            14,1;
            15,12;
            16,11;
            16,20;
            16,17;
            16,19;
            17,11;
            17,9;
            18,13:2;
            18,7;
            19,20:2;
            20,3;
            20,10:3;
        }
        \FigurVier{
            1,18,13,10::blue;
            2,19,20,10::red;
        }
        \caption{Figur 4: huepfburg0.txt Parcours}
        \label{fig:Figure4}
    \end{figure}

    \begin{table}[h!]
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            0.               & \{ 1 \}                        & \{ 2 \}                        \\
            1.               & \{ 4, 8, 18 \}                 & \{ 3, 19 \}                    \\
            2.               & \{ 4, 7, 13, 18 \}             & \{ 6, 19, 20 \}                \\
            3.               & \{ 5, 7, 10, 13 \}             & \{ 2, 3, 10, 12, 20 \}         \\
        \end{tabular}
        \caption{Tabelle 3: Schrittfolge für \hyperref[fig:Figure4]{Figur 4.}}
        \label{tab:Table3}
    \end{table}

	Bei \hyperref[fig:Figure4]{Figur 4} handelt es sich um den Beispielparcours aus der Aufgabenstellung
	beziehungsweise um den Parcours aus huepfburg0.txt aus den Eingabedateien.
	Es handelt sich daher um einen lösbaren Parcours, 
	in dem sich beide Spieler im dritten Schritt auf Feld zehn treffen.
	Wie \hyperref[tab:Table3]{Tabelle 3} zu entnehmen ist, ergibt sich im dritten Schritt der Knoten zehn aus
	der Schnittmenge der zwei Breitensuchen.
	In der Methode \hyperref[lst:sameTargetRoute]{\texttt{int[][] sameTargetRoute(\ldots)}} 
	liefert die Bedingung in der \texttt{do-while Schleife} in Schritt drei \texttt{false}.
	Daher wird im Anschluss der Zielknoten durch die Methode 
	\hyperref[lst:firstSameTargetOfTimelines]{\texttt{int firstSameTargetOfTimelines(\ldots)} }
	gesetzt und die Wege mit \hyperref[lst:findSingleRouteInTimeline]{\texttt{int[] findSingleRouteInTimeline(\ldots)}} gesetzt und anschließend wie folgt ausgegeben ausgegeben.
	
	\begin{lstlisting}[frame=single, title=Programmausgabe Figur 4., breaklines=true]
  Ergebnis für huepfburg0.txt
	Der Parcours hat folgende Lösung:
	Zielfeld: 10
	Anzahl an Schritten: 4
	Sasha's Weg: 
	1 -> 18 -> 13 -> 10
	Mika's Weg: 
	2 -> 19 -> 20 -> 10
    \end{lstlisting}

        \begin{figure}[h!]
        \centering
        \NewAdigraph{FigurFuenf}{
            1:0,1;
            2:6,1;
            3:1.5,1;
            4:4.5,1;
            5:3,0;
            6:3,1;
            7:3,2;
        }{
            1,3;
            2,4;
            3,5;
            3,6;
            3,7;
            4,5;
            4,6;
            4,7;
        }{}
        \FigurFuenf{}
        \caption{Figur 5: Parcours mit mehreren Zielknoten}
        \label{fig:Figure5}
    \end{figure}

    \begin{table}[h!]
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            0.               & \{ 1 \}                        & \{ 2 \}                        \\
            1.               & \{ 3 \}                        & \{  4 \}                         \\
            2.               & \{ 5, 6, 7 \}                  & \{ 5, 6, 7 \}                  \\
        \end{tabular}
        \caption{Tabelle 4: Schrittfolge für \hyperref[fig:Figure5]{Figur 5.}}
        \label{tab:Table4}
    \end{table}

	In \hyperref[fig:Figure5]{Figur 5.} erreichen beide Spieler im gleichen Schritt die Knoten { 5, 6, 7 }.
	Wie in \hyperref[fig:Figure4]{Figur 4.} beschrieben, wird die \texttt{do-while Schleife} beendet.
	Die Methode \hyperref[lst:firstSameTargetOfTimelines]{\texttt{int firstSameTargetOfTimelines(\ldots)} } 
	gibt hier Knoten fünf zurück, da \texttt{nextSetBit(\ldots)} den Knoten mit dem kleinsten Bezeichner gibt.
	Für die Lösung ist es unerheblich, ob ein oder mehrere Zielknoten gefunden werden, 
	da alle Zielknoten im gleichen Schritt erreicht werden. 
	Daher wird eine Lösung für den Parcours ausgegeben.
	
		\begin{lstlisting}[frame=single, title=Programmausgabe Figur 5., breaklines=true]
  Ergebnis für Figur5.txt
	Der Parcours hat folgende Lösung:
	Zielfeld: 5
	Anzahl an Schritten: 3
	Sasha's Weg: 
	1 -> 3 -> 5
	Mika's Weg: 
	2 -> 4 -> 5
    \end{lstlisting}

    \begin{figure}[h!]
        \centering
        \NewAdigraph{FigurSechs}{
            1:0,0;
            2:1,1;
            3:0,2;
            4:2,2;
            5:3,2;
            6:4,1;
            7:3,0;
            8:2,0;
        }{
            1,2;
            2,3;
            3,1;
            2,4;
            4,5;
            5,6;
            6,7;
            7,8;
            8,2;
        }{}
        \FigurSechs{}
        \caption{Figur 6: Unendlicher Parcours}
        \label{fig:Figure6}
    \end{figure}

    \begin{table}[h!]
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            0.               & \{ 1 \}                        & \{ 2 \}                        \\
            1.               & \{ 2 \}                        & \{ 3, 4 \}                     \\
            2.               & \{ 3, 4 \}                     & \{ 1, 5 \}                     \\
            3.               & \{ 1, 5 \}                     & \{ 2, 6 \}                     \\
            4.               & \{ 2, 6 \}                     & \{ 3, 4, 7 \}                  \\
            5.               & \{ 3, 4, 7 \}                  & \{ 1, 5, 8 \}                  \\
            6.               & \{ 1, 5, 8 \}                  & \{ 2, 6 \}                     \\
            7.               & \{ 2, 6 \}                     & \{ 3, 4, 7 \}                  \\
        \end{tabular}
        \caption{Tabelle 5: Schrittfolge für \hyperref[fig:Figure6]{Figur 6.}}
        \label{tab:Table5}
    \end{table}
    
    Bei \hyperref[fig:Figure6]{Figur 6.} handelt es sich um einen Parcours ohne Lösung.
    Dies ist erkennbar, da beide Spieler sich zeitgleich in ihrer Schrittfolge mit einem vorherigem Schritt wiederholen.
    Relevant ist hierbei die Abbruchbedingung der Breitensuche in 
    \hyperref[lst:sameTargetRoute]{\texttt{int[][] sameTargetRoute(\ldots)}}.
    Ohne diese würde es zu einer Endlosschleife kommen.
    In der \texttt{if Abfrage} in der Schleife, liefert der Aufruf der Methode \hyperref[lst:timelineRepeats]{\texttt{boolean timelineRepeats(\ldots)}} ein \texttt{true} in Schritt sieben.
    Die Knotenmenge \{2, 6\} von Spieler eins, wiederholt sich hier mit Schritt vier, 
    während sich zeitgleich die Knotenmenge \{3, 4, 7\} bei Spieler zwei, ebenfalls mit Schritt vier wiederholt.
    Daher wird hier \texttt{null} zurückgegeben und der Algorithmus beendet.
    
    \begin{lstlisting}[frame=single, title=Programmausgabe Figur 6., breaklines=true]
  Ergebnis für Figur6.txt
	Der Parcours hat keine Lösung!
    \end{lstlisting}
    
	
    \begin{figure}[h!]
        \centering
        \NewAdigraph{FigurSieben}{
            1:0,0;
            2:2,0;
            3:0,2;
            4:1,1;
            5:3,2;
            6:4,2;
            7:5,1;
            8:4,0;
            9:3,0;
        }{
            1,4;
            4,3;
            3,1;
            4,5;
            5,6;
            2,9;
            9,8;
            8,7;
            7,6;
        }{}
        \FigurSieben{}
        \caption{Figur 7: Sackgasse Parcours}
        \label{fig:Figure7}
    \end{figure}

    \begin{table}[h!]
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            0.               & \{ 1 \}                        & \{ 2 \}                        \\
            1.               & \{  4 \}                         & \{  9 \}                         \\
            2.               & \{  3, 5 \}                      & \{  8 \}                         \\
            3.               & \{  1, 6 \}                      & \{  7 \}                         \\
            4.               & \{  4 \}                         & \{  6 \}                         \\
            5.               & \{  3, 5 \}                      & \{  \}                           \\
        \end{tabular}
        \caption{Tabelle 6: Schrittfolge für \hyperref[fig:Figure7]{Figur 7.}}
        \label{tab:Table6}
    \end{table}

	Der Graph von \hyperref[fig:Figure7]{Figur 7.} führt in eine Sackgasse.
	Nach Schritt fünf ist es Spieler zwei nicht möglich weiter zu laufen, da es keine erreichbaren Knoten gibt.
	Die Aufgabenstellung erfordert, dass sich in jedem Schritt beide Spieler bewegen müssen.
	Da sich beide Spieler nicht auf dem gleichen knoten befinden (daher der Parcours noch nicht gelößt ist),
	kann er für ungültig erklärt werden.
	In \hyperref[lst:sameTargetRoute]{\texttt{int[][] sameTargetRoute(\ldots)}} wird in der \texttt{if Abfrage}, durch 
	\texttt{sashaTimeline.get(sashaTimeline.size() - 1).isEmpty() || mikaTimeline
    .get(mikaTimeline.size() - 1)
    .isEmpty()} gefrüft, ob einer der beiden Spieler keine erreichbaren Knoten mehr hat.
    Hier ist diese Bedingung \texttt{true} womit \texttt{null} zurückgegeben wird.
    
     \begin{lstlisting}[frame=single, title=Programmausgabe Figur 7., breaklines=true]
  Ergebnis für Figur7.txt
	Der Parcours hat keine Lösung!
    \end{lstlisting}
    
    \clearpage

    \section{Quellcode}
    \label{sec:quellcode}
    \label{LastPage}
    \begin{lstlisting}[frame=single,language=Java,title=Methode graphFromLines,breaklines=true]
    /**
     * Generiert den Graphen aus den Zeilen einer Eingabedatei.
     *
     * @param lines Eine String Liste, wo jeder String eine Zeile im Eingabeformat ist.
     * @return Den generierten Graphen.
     */
    private static BitSet[] graphFromLines(List<String> lines) {
        int countOfNodes = Integer.parseInt(lines.get(0).split(" ")[0]);
        BitSet[] graph = new BitSet[countOfNodes];
        for (int i = 0; i < countOfNodes; i++) {
            graph[i] = new BitSet(countOfNodes);
        }
        List<String> rawArrows = lines.subList(1, lines.size());
        for (String rawArrow : rawArrows) {
            int arrowBegin = Integer.parseInt(rawArrow.split(" ")[0]);
            int arrowEnd = Integer.parseInt(rawArrow.split(" ")[1]);
            graph[arrowBegin - 1].set(arrowEnd - 1);
        }
        return graph;
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode sameTargetRoute,breaklines=true]
    \label{lst:sameTargetRoute}
    /**
     * Findet eine Route, vom nullten und ersten Knoten,
     * zu einem gemeinsamen Knoten in einer gleichen Anzahl von Schritten.
     *
     * @param graph Der Graph, zu dem eine Route vom nullten und ersten Knoten zu einem gemeinsamen Knoten gebildet werden soll.
     * @return Eine Route zu einem Knoten der vom 0. und 1. Knoten in der gleichen Anzahl von Schritten erreichbar ist.
     */
    private static int[][] sameTargetRoute(BitSet[] graph) {
        BitSet sashaFirst = new BitSet(graph.length);
        BitSet mikaFirst = new BitSet(graph.length);
        sashaFirst.set(0);
        mikaFirst.set(1);
        List<BitSet> sashaTimeline = new ArrayList<>(List.of(sashaFirst));
        List<BitSet> mikaTimeline = new ArrayList<>(List.of(mikaFirst));
        do {
            sashaTimeline.add(neighbourNodes(sashaTimeline.get(sashaTimeline.size() - 1), graph));
            mikaTimeline.add(neighbourNodes(mikaTimeline.get(mikaTimeline.size() - 1), graph));
            if (sashaTimeline.get(sashaTimeline.size() - 1).isEmpty() || mikaTimeline
                    .get(mikaTimeline.size() - 1)
                    .isEmpty() || timelineRepeats(sashaTimeline, mikaTimeline)) {
                return null;
            }
        } while (!sashaTimeline.get(sashaTimeline.size() - 1).intersects(mikaTimeline.get(mikaTimeline.size() - 1)));

        int target = firstSameTargetOfTimelines(sashaTimeline, mikaTimeline);
        int[][] routes = new int[2][];
        routes[0] = findSingleRouteInTimeline(sashaTimeline, target, graph);
        routes[1] = findSingleRouteInTimeline(mikaTimeline, target, graph);
        return routes;
    }
    \end{lstlisting}

\clearpage

    \begin{lstlisting}[frame=single,language=Java,title=Methode firstSameTargetOfTimelines,breaklines=true]
    \label{lst:firstSameTargetOfTimelines}
    /**
     * Vergleicht den jeweils letzten Schritt der Schrittfolgen miteinander
     * und gibt den gemeinsamen besuchten Knoten zurück.
     *
     * @param sashaTimeline Sasha's Zeitleiste
     * @param mikaTimeline  Mika's Zeitleiste
     * @return Der Index im Graphen des gemeinsamen Knotens.
     */
    private static int firstSameTargetOfTimelines(List<BitSet> sashaTimeline, List<BitSet> mikaTimeline) {
        BitSet targets = (BitSet) sashaTimeline.get(sashaTimeline.size() - 1).clone();
        targets.and(mikaTimeline.get(mikaTimeline.size() - 1));
        return targets.nextSetBit(0);
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode findSingleRouteInTimeline,breaklines=true]
    \label{lst:findSingleRouteInTimeline}
    /**
     * Ermittelt den Weg vom Zielpunkt zurück zum Startpunkt entgegengesetzt der Kantenrichtung des Graphen.
     *
     * @param timeline Die Zeitleiste der erreichbaren Knoten,
     *                 von der eine Route zu einem bestimmten Knoten im letzten Zeitpunkt der Zeitleiste gebaut werden soll.
     * @param target   Das Ziel am Ende der Zeitleiste der erreichbaren Knoten, zudem eine Route gebaut werden soll.
     * @param graph    Der Graph aus dem die Zeitleiste der erreichbaren Knoten (und dementsprechend auch das Ziel) stammt.
     * @return Eine Route zum Ziel in der Zeitleiste.
     */
    private static int[] findSingleRouteInTimeline(List<BitSet> timeline, int target, BitSet[] graph) {
        int[] route = new int[timeline.size()];
        steps:
        for (int currentStep = timeline.size() - 1; currentStep > 0; currentStep--) {
            route[currentStep] = target;
            BitSet currentNodes = timeline.get(currentStep - 1);
            for (int i = 0; i < graph.length; i++) {
                if (currentNodes.get(i)) {
                    BitSet arrows = graph[i];
                    if (arrows.get(target)) {
                        target = i;
                        continue steps;
                    }
                }
            }
        }
        route[0] = target;
        return route;
    }
    \end{lstlisting}

\clearpage

    \begin{lstlisting}[frame=single,language=Java,title=Methode neighbourNodes,breaklines=true]
    /**
     * Gibt die Knoten zurück, welche in einem Schritt entlang der Kantenrichtung,
     * von den aktuellen Knoten erreichbar sind.
     *
     * @param nodes Die aktuellen Knoten
     * @param graph Der Graph, welcher betrachtet wird
     * @return Die Menge der Knoten die in einem Schritt von den gegebenen Knoten erreichbar ist
     */
    private static BitSet neighbourNodes(BitSet nodes, BitSet[] graph) {
        BitSet neighbours = new BitSet();
        for (int i = 0; i < graph.length; i++) {
            if (nodes.get(i)) {
                neighbours.or(graph[i]);
            }
        }
        return neighbours;
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode timelineRepeats,breaklines=true]
    \label{lst:timelineRepeats}
    /**
     * Ermittelt, ob die zwei Zeitleisten sich zu einem Zeitpunkt mit ihrem letzten Eintrag wiederholen.
     * Es wird daher festgestellt, ob beide Zeitleisten zu einem vorherigen Zeitpunkt an den genau gleichen Knoten waren,
     * wie zum aktuellen Zeitpunkt.
     *
     * @param sashaTimeline Sasha's Zeitleiste der erreichbaren Knoten
     * @param mikaTimeline  Mika's Zeitleiste der erreichbaren Knoten
     * @return True, wenn die Zeitleisten sich beide zu einem gleichen Zeitpunkt
     * mit dem neuen/letzten Zeitpunkt wiederholen.
     */
    private static boolean timelineRepeats(List<BitSet> sashaTimeline, List<BitSet> mikaTimeline) {
        BitSet current = sashaTimeline.get(sashaTimeline.size() - 1);
        BitSet repetitions = new BitSet(sashaTimeline.size());
        List<BitSet> timeline = new ArrayList<>(sashaTimeline.subList(0, sashaTimeline.size() - 1));
        for (int i = 0; i < timeline.size(); i++) {
            if (timeline.get(i).equals(current)) {
                repetitions.set(i);
            }
        }
        for (int i = repetitions.nextSetBit(0); i >= 0; i = repetitions.nextSetBit(i + 1)) {
            if (mikaTimeline.get(mikaTimeline.size() - 1).equals(mikaTimeline.get(i))) {
                return true;
            }
        }
        return false;
    }
    \end{lstlisting}
\end{document}
