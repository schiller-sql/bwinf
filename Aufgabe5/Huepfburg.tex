\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten vier Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 5: Hüpfburg}        % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeamId}{00919}                       % Team-ID aus dem PMS angeben
\newcommand{\TeamName}{Object Grind}              % Team-Namen angeben
\newcommand{\Namen}{Lennart Protte}               % Namen der Bearbeiter/-innen dieser Aufgabe angeben

% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Team-ID: \TeamId}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

% Für Algorithmen
\usepackage{algpseudocode}
\usepackage{adigraph}

% Für Quelltext
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
    keywordstyle=\color{blue},commentstyle=\color{mygreen},
    stringstyle=\color{mymauve},rulecolor=\color{black},
    basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
    captionpos=b, % sets the caption-position to bottom
    keepspaces=true, % keeps spaces in text
    numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
    showtabs=false, stepnumber=2, tabsize=2, title=\lstname ,
    inputencoding = utf8,  % Input encoding
    extendedchars = true,  % Extended ASCII
    literate      =        % Support additional characters
        {á}{{\'a}}1  {é}{{\'e}}1  {í}{{\'i}}1 {ó}{{\'o}}1  {ú}{{\'u}}1
        {Á}{{\'A}}1  {É}{{\'E}}1  {Í}{{\'I}}1 {Ó}{{\'O}}1  {Ú}{{\'U}}1
        {à}{{\`a}}1  {è}{{\`e}}1  {ì}{{\`i}}1 {ò}{{\`o}}1  {ù}{{\`u}}1
        {À}{{\`A}}1  {È}{{\'E}}1  {Ì}{{\`I}}1 {Ò}{{\`O}}1  {Ù}{{\`U}}1
        {ä}{{\"a}}1  {ë}{{\"e}}1  {ï}{{\"i}}1 {ö}{{\"o}}1  {ü}{{\"u}}1
        {Ä}{{\"A}}1  {Ë}{{\"E}}1  {Ï}{{\"I}}1 {Ö}{{\"O}}1  {Ü}{{\"U}}1
        {â}{{\^a}}1  {ê}{{\^e}}1  {î}{{\^i}}1 {ô}{{\^o}}1  {û}{{\^u}}1
        {Â}{{\^A}}1  {Ê}{{\^E}}1  {Î}{{\^I}}1 {Ô}{{\^O}}1  {Û}{{\^U}}1
        {œ}{{\oe}}1  {Œ}{{\OE}}1  {æ}{{\ae}}1 {Æ}{{\AE}}1  {ß}{{\ss}}1
        {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1  {Ø}{{\O}}1   {å}{{\r a}}1
        {Å}{{\r A}}1 {ã}{{\~a}}1  {õ}{{\~o}}1 {Ã}{{\~A}}1  {Õ}{{\~O}}1
        {ñ}{{\~n}}1  {Ñ}{{\~N}}1  {¿}{{?`}}1  {¡}{{!`}}1
        {°}{{\textdegree}}1 {º}{{\textordmasculine}}1 {ª}{{\textordfeminine}}1
}
\lstdefinelanguage{JavaScript}{ % JavaScript ist als einzige Sprache noch nicht vordefiniert
    keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with},
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]',
    morestring=[b]",
    sensitive=true
}

% Diese beiden Pakete müssen zuletzt geladen werden
\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}
\usepackage{textcomp}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Team-ID: \LARGE \TeamId \\\\
\LARGE Team-Name: \LARGE \TeamName \\\\
\LARGE Bearbeiter/-innen dieser Aufgabe: \\
\LARGE \Namen\\\\}
\date{\LARGE\today}

\begin{document}

    \maketitle
    \tableofcontents

    \vspace{0.5cm}
%TODO: Schrittfolge als Begriff durchgängig verwenden


    \section{Lösungsidee}\label{sec:losungsidee}
    Der Aufgabenstellung zu entnehmen ist,
    dass sich beide Spieler immer genau gleichzeitig,
    um genau einen Punkt,
    entlang der Pfeilrichtung bewegen und der Parcours als absolviert gilt,
    wenn sich beide gleichzeitig auf den gleichen Punkt bewegen.
    Dabei ist die Startposition der Spieler jeweils immer identisch.

    Als Datenstruktur für den Parcours eignet sich ein gerichteter und ungewichteter Graph.
    Die Pfeile zwischen den Kästchen werden durch gerichtete Kanten repräsentiert,
    während die Knoten repräsentativ für die Felder stehen.

    Die abstrahierte Problemstellung der Aufgabe ist es,
    für jeden der zwei Ausgangspunkte,
    jeweils einen Weg zu einem Knoten,
    in einem gerichteten und ungewichteten Graphen,
    zu finden.
    Dieser muss von beiden Ausgangsknoten mit der gleichen Anzahl an Schritten zu erreichen sein.
    Dabei darf die Schrittfolge nie entgegengesetzt zur Kantenrichtung verlaufen.

    Dies kann erreicht werden,
    indem für beide Spieler eine Breitensuche parallel schrittweise durchgeführt wird.
    Davon ausgehend, dass es dabei zu einem gemeinsamen Schnittpunkt kommt,
    wird die Breitensuche fortgesetzt,
    bis sich mindestens ein Knoten aus der Schnittmenge der beiden Suchen ergibt.
    Wenn es sich um einen lösbaren Parcours handelt,
    wird für beide Spieler im selben Schritt mindestens ein gleicher Knoten gefunden.

    Sollte der Parcours nicht lösbar ist,
    ist die Menge der markierten Knoten,
    für beide Spieler zur gleichen Zeit,
    irgendwann gleich der Menge,
    der zu einem früheren Zeitpunkt markierten Knoten.

    \begin{figure}
        \centering
        \NewAdigraph{FigurEins}{
            1:0,0;
            2:2,0;
            3:1,1;
        }{
            1,2;
            2,3;
            3,1;
        }{}
        \FigurEins{}
        \caption{Nicht lösbarer zyklischer Parcours}
        \label{fig:Figure1}
    \end{figure}

    So kommt es in \hyperref[fig:Figure1]{Figur 1.}
    zu einer zeitgleichen Wiederholung der Knotenmenge bei beiden Spielern.

    \begin{table}
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            0.               & \{ 1 \}                        & \{ 2 \}                        \\
            1.               & \{ 2 \}                        & \{ 3 \}                        \\
            2.               & \{ 3 \}                        & \{ 1 \}                        \\
            3.               & \{ 1 \}                        & \{ 2 \}                        \\
        \end{tabular}
        \caption{Schrittfolge für \hyperref[fig:Figure1]{Figur 1.}}
        \label{tab:Table1}
    \end{table}

    Hier kommt es in Schritt drei bei beiden Spielern zu einer Wiederholung von Schritt null.
    Damit kann der Parcours sicher für ungültig erklärt werden
    und die Suche nach einem gemeinsamen Zielpunkt kann abgebrochen werden.
    Dies gilt, da sich beide Spieler in einem Zyklus befinden
    und im ersten Durchlauf des Zyklus kein gemeinsamer Punkt gefunden wurde.

    Der Parcours ist ebenfalls nicht lösbar, sollte eine der beiden oder beide Knotenmengen leer sein.
    Dies gilt, da im nächsten Schritt keine weiteren Knoten für die leere Knotenmenge erreichbar wären
    und somit für einen der beiden Spieler kein Schritt mehr möglich ist.
    Da die Aufgabenstellung allerdings vorgibt, dass sich in jedem Schritt beide Spieler bewegen müssen,
    ist der Parcours damit für ungültig zu erklären.
    So kommt es in \hyperref[fig:Figure2]{Figur 2.} zu einer solchen Sackgasse für einen der Spieler.

    \begin{figure}[!h]
        \centering
        \NewAdigraph{FigurZwei}{
            1:0,0;
            2:4.5,0;
            3:1.5,0;
            4:3,0;
        }{
            1,3;
            3,4;
            2,4;
        }{}
        \FigurZwei{}
        \caption{Nicht lösbarer Parcours mit Sackgasse}
        \label{fig:Figure2}
    \end{figure}

    \begin{table}[!h]
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            0.               & \{ 1 \}                        & \{ 2 \}                        \\
            1.               & \{ 3 \}                        & \{  4\}                          \\
            2.               & \{ 4 \}                        & \{  \}                           \\
        \end{tabular}
        \caption{Schrittfolge für \hyperref[fig:Figure2]{Figur 2.}}
        \label{tab:Table2}
    \end{table}

    Hier kommt es bereits im zweiten Schritt dazu, dass die Knotenmenge des zweiten Spielers leer ist.
    Damit ist es unmöglich das Spieler eins und Spieler zwei sich jemals treffen werden,
    da Spieler zwei keinen weiteren Schritt gehen kann und sie sich noch nicht auf dem gleichen Feld befinden.

    Im Algorithmus muss also in jedem Schritt der Breitensuche überprüft werden,
    ob die aktuelle Knotenmenge von beiden Spielern sich
    mit einem gemeinsamen Zeitpunkt in der Vergangenheit wiederholt.
    Dazu muss eine Liste an bisherigen Knotenmengen beider Spieler geführt werden.
    Auch muss überprüft werden ob einer der beiden Knotenmengen leer ist.
    Ist einer dieser Bedingungen erfüllt, ist der Graph nicht lösbar
    und die Suche nach einem gemeinsamen Feld kann abgebrochen werden.
    Andernfalls kann überprüft werden,
    ob die beiden neuen Knotenmengen sich überschneiden.
    Ist dies der Fall, kann der Parcours in diesem Schritt an einem Feld
    von beiden Spielern gleichzeitig erreicht werden und ist somit lösbar.
    Ist keine der Bedingungen Bedingung nicht erfüllt,
    folgt ein weiterer Schritt der Breitensuche.

    Sobald der Zielpunkt gefunden ist,
    wo sich beide Schrittfolgen überschneiden,
    gilt es einen Weg von den Startknoten zu diesem Zielknoten zu finden.
    Gibt es mehrere Zielpunkte, kann ein beliebiger gewählt werden,
    da alle mit der gleichen Schrittanzahl erreicht werden können.

    Aus dem ermittelten Zielknoten, den gegebenen Startknoten und
    der generierten Schrittfolge von jedem Startknoten zum Zielknoten,
    lässt sich nun der Weg für jeden der Startknoten bestimmen.
    Der letzte Eintrag in den Schrittfolgen beinhaltet nun den Zielknoten,
    während der erste Eintrag den jeweiligen Startknoten enthält.

    Zunächst kann im Weg vom Startknoten zum Zielknoten der Zielknoten selbst an letzter Stelle eingetragen werden.
    Es lässt sich nun in jeder Schrittfolge der vorletzte Schritt betrachten.
    In diesem Schritt kann nun ein Knoten ermittelt werden,
    welcher als Nachbar entlang der Kantenrichtung den Zielknoten besitzt.
    Ist dieser Knoten gefunden,
    kann er im Weg an der entsprechenden Stelle (hier an der vorletzten) gespeichert werden.
    Dieses Verfahren wird nun solange für den nächsten Schritt und den zuletzt in den Weg eingefügten Knoten wiederholt,
    bis man am Startknoten angelangt ist.


    \section{Umsetzung}\label{sec:umsetzung}

    % Beispiel graph mit matrix daneben zur visualisierung
    Eine Menge von Knoten wird als \texttt{BitSet} dargestellt.
    Ein \texttt{BitSet} in Java ist eine lineare statische Datenstruktur,
    welche Bits, die alle anhand eines Indexes gesetzt werden können.
    Die Länge jedes \texttt{BitSet} ist gleich der Anzahl der Knoten des Graphen
    und jeder Index korrespondiert zu einem Knoten.
    Ist an diesen Index im \texttt{BitSet} eine eins,
    ist der Knoten in der Knotenmenge enthalten, andernfalls ist er es nicht.
    Beispielsweise gilt $0101 \widehat{=} \{2, 4\}$.
    Da der erste Index eines \texttt{BitSet} null ist,
    korrespondiert der Index null zu Knoten eins des Parcours.

    Ein Graph wird als \texttt{BitSet[]} dargestellt.
    Jeder Index des Arrays korrespondiert zu einem Knoten.
    Das am Index eines Knoten enthaltene \texttt{BitSet}, ist eine Knotenmenge.
    Diese stellt da, zu welchen Knoten eine Kante ausgeht.




    \begin{figure}[!h]
        \centering
        \NewAdigraph{FigurDrei}{
            1:0,0;
            2:1.5,0;
            3:0.75,1;
            4:2.5,1;
        }{
            1,2;
            2,3;
            2,4;
            1,3;
        }
        \FigurDrei{
            1,2,3::blue;
        }
        \caption{Graph der Matrix}

        \label{fig:Figure3}
    \end{figure}

    \[
        Graph = \begin{bmatrix}
                    0 & 1 & 1 & 0 \\
                    0 & 0 & 1 & 1 \\
                    0 & 0 & 0 & 0 \\
                    0 & 0 & 0 & 0 \\
        \end{bmatrix}
    \]

    Die Schrittfolge ist eine \texttt{List<BitSet>},
    d.h. eine \texttt{List} aus \texttt{BitSet}.
    Index null der \texttt{List} korrespondiert zum Ausgangspunkt,
    daher Schritt null beziehungsweise zur Startposition.
    \[
        Schrittfolge = \left\lbrace
        \begin{tabular}{ll}
            \underline{\text{List Index:}} & \underline{\text{BitSet:}} \\
            0                              & \{  1000\}                   \\
            1                              & \{  0100\}                   \\
            2                              & \{  0010\}                   \\
        \end{tabular}
        \right\rbrace
    \]

    Ein Weg ist ein \texttt{int[]}.
    Dabei repräsentiert der Index null den Ausgangspunkt des Weges.
    Aufgrund der Tatsache, dass im Graphen der Index null, dem Knoten eins entspricht,
    sind die Werte im Weg um eins niedriger eingetragen, als die tatsächlichen Knoten.
    Ist beispielsweise am Index zwei der Integer drei eingetragen,
    befindet sich an der dritten Position des Weges der Knoten vier.
    Dies wird in der Ausgabe berücksichtigt, wo zu jedem Wert eins addiert wird.

    - Transformation von Idee in Programm

    - kein Echter Code aber Pseudo Code

    - Angeben, in welchen Methoden welcher Algorithmische teil

    - Wie wurde Modelliert

    -


    \section{Beispiele}\label{sec:beispiele}

    - Darstellen, was bei einem Programmablauf passiert

    \begin{figure}[h!]
        \centering
        \NewAdigraph{FigurVier}{
            1:0,0;
            2:1,1;
            3:0,2;
            4:2,2;
            5:3,2;
            6:4,1;
            7:3,0;
            8:2,0;
        }{
            1,2;
            2,3;
            3,1;
            2,4;
            4,5;
            5,6;
            6,7;
            7,8;
            8,2;
        }{}
        \FigurVier{}
        \caption{Unendlicher Parcours}
        \label{fig:Figure4}
    \end{figure}

    \begin{table}[h!]
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            0.               & \{ 1 \}                        & \{ 2 \}                        \\
            1.               & \{ 2 \}                        & \{  3, 4\}                       \\
            2.               & \{ 3, 4\}                      & \{  1, 5\}                       \\
            3.               & \{ 1, 5 \}                     & \{  2, 6\}                       \\
            4.               & \{ 2, 6 \}                     & \{  3, 4, 7\}                    \\
            5.               & \{ 3, 4, 7 \}                  & \{  1, 5, 8\}                    \\
            6.               & \{  1, 5, 8\}                    & \{ 2, 6 \}                     \\
            7.               & \{  2, 6\}                       & \{  3, 4, 7\}                    \\
        \end{tabular}
        \caption{Schrittfolge für \hyperref[fig:Figure4]{Figur 3.}}
        \label{tab:Table3}
    \end{table}

    -Breitensuche ohne Abbruchbedingung würde hier unendlich lange weiter laufen

    -Abbruch in Schritt acht, da wiederholung mit Schritt fünf

    -teil zyklen (1,2,3,1,2,3,... bei spieler eins) sind dabei nicht ausschlaggebend




    \begin{figure}[h!]
        \centering
        \NewAdigraph{FigurFuenf}{
            1:0,0;
            2:2,0;
            3:0,2;
            4:1,1;
            5:3,2;
            6:4,2;
            7:5,1;
            8:4,0;
            9:3,0;
        }{
            1,4;
            4,3;
            3,1;
            4,5;
            5,6;
            2,9;
            9,8;
            8,7;
            7,6;
        }{}
        \FigurFuenf{}
        \caption{Sackgasse Parcours}
        \label{fig:Figure5}
    \end{figure}

    \begin{table}[h!]
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            0.               & \{ 1 \}                        & \{ 2 \}                        \\
            1.               & \{  4\}                          & \{  9\}                          \\
            2.               & \{  3, 5\}                       & \{  8\}                          \\
            3.               & \{  1, 6\}                       & \{  7\}                          \\
            4.               & \{  4\}                          & \{  6\}                          \\
            5.               & \{  3, 5\}                       & \{  \}                           \\
        \end{tabular}
        \caption{Schrittfolge für \hyperref[fig:Figure5]{Figur 5.}}
        \label{tab:Table4}
    \end{table}

    %TODO überprüfen, ob unser Algorithmus wirklich an dieser Stelle abbricht oder eins später 
    % @ \hyperref[fig:Figure4]{Figur 4.}
    führt an knoten sechs in eine sackgasse für Spieler zwei von Schritt fünf auf sechs
    daher ist es nicht möglich, nach schritt sechs für spieler zwei weiter zu laufen

    -da beide spieler sich in jedem schritt immer um genau ein feld bewegen müssen
    es ist also nicht möglich für den einen spieler stehen zu bleiben,
    während der andere sich noch weiter bewegt
    -

    \begin{figure}[h!]
        \centering
        \NewAdigraph{FigurSechs}{
            1:3,0;
            2:-3.5,-1;
            3:-1.5,0;
            4:4,0;
            5:0,3;
            6:-3.5,1;
            7:1.5,3;
            8:3.5,1.5;
            9:3,-1.5;
            10:0,0;
            11:0,-3;
            12:-1.5,1.5;
            13:0,1.5;
            14:1.5,0;
            15:-3,3;
            16:0,-1.5;
            17:2,-3;
            18:1.5,1.5;
            19:-2.5,-3;
            20:-1.5,-1.5;
        }{
            1,18:1;
            1,8;
            1,4;
            2,3;
            2,19:1;
            3,19;
            3,6;
            5,15;
            5,12;
            5,13;
            6,2;
            6,12;
            7,5;
            7,8;
            8,18;
            8,4;
            9,4;
            9,1;
            9,14;
            10,16;
            10,3;
            10,12;
            10,18;
            11,19;
            12,3;
            13,7;
            13,10:3;
            14,17;
            14,16;
            14,10;
            14,18;
            14,1;
            15,12;
            16,11;
            16,20;
            16,17;
            16,19;
            17,11;
            17,9;
            18,13:2;
            18,7;
            19,20:2;
            20,3;
            20,10:3;
        }
        \FigurSechs{
            1,18,13,10::blue;
            2,19,20,10::red;
        }
        \caption{huepfburg0.txt Parcours}
        \label{fig:Figure6}
    \end{figure}

    \begin{table}[h!]
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            0.               & \{ 1 \}                        & \{ 2 \}                        \\
            1.               & \{ 4, 8, 18 \}                 & \{ 3, 19 \}                    \\
            2.               & \{ 4, 7, 13, 18 \}             & \{ 6, 19, 20 \}                \\
            3.               & \{ 5, 7, 10, 13 \}             & \{ 2, 3, 10, 12, 20 \}         \\
        \end{tabular}
        \caption{Schrittfolge für \hyperref[fig:Figure6]{Figur 6.}}
        \label{tab:Table5}
    \end{table}

    -der graph aus dem beispiel huepfburg0.txt

    -lösbarer parcours

    -breitensuche findet im dritten schritt einen gemeinsamen nenner

    %TODO Beispiel, wo mehrere Zielknoten gefunden werden


    \section{Quellcode}
    \label{sec:quellcode}
    \label{LastPage}
    \begin{lstlisting}[frame=single,language=Java,title=Methode graphFromLines,breaklines=true]
    /**
     * Generiert den Graphen aus den Zeilen einer Eingabedatei.
     *
     * @param lines Eine String Liste, wo jeder String eine Zeile im Eingabeformat ist.
     * @return Den generierten Graphen.
     */
    private static BitSet[] graphFromLines(List<String> lines) {
        int countOfNodes = Integer.parseInt(lines.get(0).split(" ")[0]);
        BitSet[] graph = new BitSet[countOfNodes];
        for (int i = 0; i < countOfNodes; i++) {
            graph[i] = new BitSet(countOfNodes);
        }
        List<String> rawArrows = lines.subList(1, lines.size());
        for (String rawArrow : rawArrows) {
            int arrowBegin = Integer.parseInt(rawArrow.split(" ")[0]);
            int arrowEnd = Integer.parseInt(rawArrow.split(" ")[1]);
            graph[arrowBegin - 1].set(arrowEnd - 1);
        }
        return graph;
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode sameTargetRoute,breaklines=true]
    /**
     * Findet eine Route, vom nullten und ersten Knoten,
     * zu einem gemeinsamen Knoten in einer gleichen Anzahl von Schritten.
     *
     * @param graph Der Graph, zu dem eine Route vom nullten und ersten Knoten zu einem gemeinsamen Knoten gebildet werden soll.
     * @return Eine Route zu einem Knoten der vom 0. und 1. Knoten in der gleichen Anzahl von Schritten erreichbar ist.
     */
    private static int[][] sameTargetRoute(BitSet[] graph) {
        BitSet sashaFirst = new BitSet(graph.length);
        BitSet mikaFirst = new BitSet(graph.length);
        sashaFirst.set(0);
        mikaFirst.set(1);
        List<BitSet> sashaTimeline = new ArrayList<>(List.of(sashaFirst));
        List<BitSet> mikaTimeline = new ArrayList<>(List.of(mikaFirst));
        do {
            sashaTimeline.add(neighbourNodes(sashaTimeline.get(sashaTimeline.size() - 1), graph));
            mikaTimeline.add(neighbourNodes(mikaTimeline.get(mikaTimeline.size() - 1), graph));
            if (sashaTimeline.get(sashaTimeline.size() - 1).isEmpty() || mikaTimeline
                    .get(mikaTimeline.size() - 1)
                    .isEmpty() || timelineRepeats(sashaTimeline, mikaTimeline)) {
                return null;
            }
        } while (!sashaTimeline.get(sashaTimeline.size() - 1).intersects(mikaTimeline.get(mikaTimeline.size() - 1)));

        int target = firstSameTargetOfTimelines(sashaTimeline, mikaTimeline);
        int[][] routes = new int[2][];
        routes[0] = findSingleRouteInTimeline(sashaTimeline, target, graph);
        routes[1] = findSingleRouteInTimeline(mikaTimeline, target, graph);
        return routes;
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode firstSameTargetOfTimelines,breaklines=true]
    /**
     * Vergleicht den jeweils letzten Schritt der Schrittfolgen miteinander
     * und gibt den gemeinsamen besuchten Knoten zurück.
     *
     * @param sashaTimeline Sasha's Zeitleiste
     * @param mikaTimeline  Mika's Zeitleiste
     * @return Der Index im Graphen des gemeinsamen Knotens.
     */
    private static int firstSameTargetOfTimelines(List<BitSet> sashaTimeline, List<BitSet> mikaTimeline) {
        BitSet targets = (BitSet) sashaTimeline.get(sashaTimeline.size() - 1).clone();
        targets.and(mikaTimeline.get(mikaTimeline.size() - 1));
        return targets.nextSetBit(0);
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode findSingleRouteInTimeline,breaklines=true]
    /**
     * Ermittelt den Weg vom Zielpunkt zurück zum Startpunkt entgegengesetzt der Kantenrichtung des Graphen.
     *
     * @param timeline Die Zeitleiste der erreichbaren Knoten,
     *                 von der eine Route zu einem bestimmten Knoten im letzten Zeitpunkt der Zeitleiste gebaut werden soll.
     * @param target   Das Ziel am Ende der Zeitleiste der erreichbaren Knoten, zudem eine Route gebaut werden soll.
     * @param graph    Der Graph aus dem die Zeitleiste der erreichbaren Knoten (und dementsprechend auch das Ziel) stammt.
     * @return Eine Route zum Ziel in der Zeitleiste.
     */
    private static int[] findSingleRouteInTimeline(List<BitSet> timeline, int target, BitSet[] graph) {
        int[] route = new int[timeline.size()];
        steps:
        for (int currentStep = timeline.size() - 1; currentStep > 0; currentStep--) {
            route[currentStep] = target;
            BitSet currentNodes = timeline.get(currentStep - 1);
            for (int i = 0; i < graph.length; i++) {
                if (currentNodes.get(i)) {
                    BitSet arrows = graph[i];
                    if (arrows.get(target)) {
                        target = i;
                        continue steps;
                    }
                }
            }
        }
        route[0] = target;
        return route;
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode neighbourNodes,breaklines=true]
    /**
     * Gibt die Knoten zurück, welche in einem Schritt entlang der Kantenrichtung,
     * von den aktuellen Knoten erreichbar sind.
     *
     * @param nodes Die aktuellen Knoten
     * @param graph Der Graph, welcher betrachtet wird
     * @return Die Menge der Knoten die in einem Schritt von den gegebenen Knoten erreichbar ist
     */
    private static BitSet neighbourNodes(BitSet nodes, BitSet[] graph) {
        BitSet neighbours = new BitSet();
        for (int i = 0; i < graph.length; i++) {
            if (nodes.get(i)) {
                neighbours.or(graph[i]);
            }
        }
        return neighbours;
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode timelineRepeats,breaklines=true]
    /**
     * Ermittelt, ob die zwei Zeitleisten sich zu einem Zeitpunkt mit ihrem letzten Eintrag wiederholen.
     * Es wird daher festgestellt, ob beide Zeitleisten zu einem vorherigen Zeitpunkt an den genau gleichen Knoten waren,
     * wie zum aktuellen Zeitpunkt.
     *
     * @param sashaTimeline Sasha's Zeitleiste der erreichbaren Knoten
     * @param mikaTimeline  Mika's Zeitleiste der erreichbaren Knoten
     * @return True, wenn die Zeitleisten sich beide zu einem gleichen Zeitpunkt
     * mit dem neuen/letzten Zeitpunkt wiederholen.
     */
    private static boolean timelineRepeats(List<BitSet> sashaTimeline, List<BitSet> mikaTimeline) {
        BitSet current = sashaTimeline.get(sashaTimeline.size() - 1);
        BitSet repetitions = new BitSet(sashaTimeline.size());
        List<BitSet> timeline = new ArrayList<>(sashaTimeline.subList(0, sashaTimeline.size() - 1));
        for (int i = 0; i < timeline.size(); i++) {
            if (timeline.get(i).equals(current)) {
                repetitions.set(i);
            }
        }
        for (int i = repetitions.nextSetBit(0); i >= 0; i = repetitions.nextSetBit(i + 1)) {
            if (mikaTimeline.get(mikaTimeline.size() - 1).equals(mikaTimeline.get(i))) {
                return true;
            }
        }
        return false;
    }
    \end{lstlisting}
\end{document}
