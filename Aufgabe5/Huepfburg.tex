\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten vier Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 5: Hüpfburg}        % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeamId}{?????}                       % Team-ID aus dem PMS angeben
\newcommand{\TeamName}{????}                      % Team-Namen angeben
\newcommand{\Namen}{Tony Borchert, Lennart Protte}% Namen der Bearbeiter/-innen dieser Aufgabe angeben

% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Team-ID: \TeamId}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

% Für Algorithmen
\usepackage{algpseudocode}
\usepackage{adigraph}

% Für Quelltext
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
    keywordstyle=\color{blue},commentstyle=\color{mygreen},
    stringstyle=\color{mymauve},rulecolor=\color{black},
    basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
    captionpos=b, % sets the caption-position to bottom
    keepspaces=true, % keeps spaces in text
    numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
    showtabs=false, stepnumber=2, tabsize=2, title=\lstname ,
    inputencoding = utf8,  % Input encoding
    extendedchars = true,  % Extended ASCII
    literate      =        % Support additional characters
        {á}{{\'a}}1  {é}{{\'e}}1  {í}{{\'i}}1 {ó}{{\'o}}1  {ú}{{\'u}}1
        {Á}{{\'A}}1  {É}{{\'E}}1  {Í}{{\'I}}1 {Ó}{{\'O}}1  {Ú}{{\'U}}1
        {à}{{\`a}}1  {è}{{\`e}}1  {ì}{{\`i}}1 {ò}{{\`o}}1  {ù}{{\`u}}1
        {À}{{\`A}}1  {È}{{\'E}}1  {Ì}{{\`I}}1 {Ò}{{\`O}}1  {Ù}{{\`U}}1
        {ä}{{\"a}}1  {ë}{{\"e}}1  {ï}{{\"i}}1 {ö}{{\"o}}1  {ü}{{\"u}}1
        {Ä}{{\"A}}1  {Ë}{{\"E}}1  {Ï}{{\"I}}1 {Ö}{{\"O}}1  {Ü}{{\"U}}1
        {â}{{\^a}}1  {ê}{{\^e}}1  {î}{{\^i}}1 {ô}{{\^o}}1  {û}{{\^u}}1
        {Â}{{\^A}}1  {Ê}{{\^E}}1  {Î}{{\^I}}1 {Ô}{{\^O}}1  {Û}{{\^U}}1
        {œ}{{\oe}}1  {Œ}{{\OE}}1  {æ}{{\ae}}1 {Æ}{{\AE}}1  {ß}{{\ss}}1
        {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1  {Ø}{{\O}}1   {å}{{\r a}}1
        {Å}{{\r A}}1 {ã}{{\~a}}1  {õ}{{\~o}}1 {Ã}{{\~A}}1  {Õ}{{\~O}}1
        {ñ}{{\~n}}1  {Ñ}{{\~N}}1  {¿}{{?`}}1  {¡}{{!`}}1
        {°}{{\textdegree}}1 {º}{{\textordmasculine}}1 {ª}{{\textordfeminine}}1
}
\lstdefinelanguage{JavaScript}{ % JavaScript ist als einzige Sprache noch nicht vordefiniert
    keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with},
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]',
    morestring=[b]",
    sensitive=true
}

% Diese beiden Pakete müssen zuletzt geladen werden
\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Team-ID: \LARGE \TeamId \\\\
\LARGE Team-Name: \LARGE \TeamName \\\\
\LARGE Bearbeiter/-innen dieser Aufgabe: \\
\LARGE \Namen\\\\}
\date{\LARGE\today}

\begin{document}

    \maketitle
    \tableofcontents

    \vspace{0.5cm}


    \section{Lösungsidee}\label{sec:losungsidee}
    Der Aufgabenstellung zu entnehmen ist,
    dass sich beide Spieler immer genau gleichzeitig,
    um genau einen Punkt,
    entlang der Pfeilrichtung bewegen und der Parcours als absolviert gilt,
    wenn sich beide gleichzeitig auf den gleichen Punkt bewegen.
    Dabei ist die Startposition der Spieler jeweils immer identisch.

    Als Datenstruktur für den Parcours eignet sich ein gerichteter und ungewichteter Graph.
    Die Pfeile zwischen den Kästchen werden durch gerichtete Kanten repräsentiert,
    während die Knoten repräsentativ für die Felder stehen.

    Die abstrahierte Problemstellung der Aufgabe ist es,
    für jeden der zwei Ausgangspunkte,
    jeweils einen Weg zu einem Knoten,
    in einem gerichteten und ungewichteten Graphen,
    zu finden.
    Dieser muss von beiden Ausgangsknoten mit der gleichen Anzahl an Schritten zu erreichen sein.
    Dabei darf die Schrittfolge nie entgegengesetzt zur Kantenrichtung verlaufen.

    Dies kann erreicht werden,
    indem für beide Spieler eine Breitensuche parallel schrittweise durchgeführt wird.
    Davon ausgehend, dass es dabei zu einem gemeinsamen Schnittpunkt kommt,
    wird die Breitensuche fortgesetzt,
    bis sich mindestens ein Knoten aus der Schnittmenge der beiden Suchen ergibt.
    Wenn es sich um einen lösbaren Parcours handelt,
    wird für beide Spieler im selben Schritt mindestens ein gleicher Knoten gefunden.

    Sollte der Parcours nicht lösbar ist,
    ist die Menge der markierten Knoten,
    für beide Spieler zur gleichen Zeit,
    irgendwann gleich der Menge,
    der zu einem früheren Zeitpunkt markierten Knoten.

    \begin{figure}
        \centering
        \NewAdigraph{InfinityLoop}{
            1:0,0;
            2:2,0;
            3:1,1;
        }{
            1,2;
            2,3;
            3,1;
        }{}
        \InfinityLoop{}
        \caption{Nicht lösbarer zyklischer Parcour}
        \label{fig:Figure1}
    \end{figure}

    So kommt es in \hyperref[fig:Figure1]{Figur 1.} zu einer zeitgleichen Wiederholung der Knotenmenge bei beiden Spielern.

    \begin{table}
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            1.               & \{ 1 \}                        & \{ 2 \}                        \\
            2.               & \{ 2 \}                        & \{ 3 \}                        \\
            3.               & \{ 3 \}                        & \{ 1 \}                        \\
            4.               & \{ 1 \}                        & \{ 2 \}                        \\
        \end{tabular}
        \caption{Schrittfolge für Figur 1.}
        \label{tab:Table1}
    \end{table}

    Hier kommt es in Schritt vier bei beiden Spielern zu einer Wiederholung von Schritt eins.
    Damit kann der Parcours sicher für ungültig erklärt werden
    und die Suche nach einem gemeinsamen Zielpunkt kann abgebrochen werden.
    Dies gilt, da sich beide Spieler in einem Zyklus befinden
    und im ersten Durchlauf des Zyklus kein gemeinsamer Punkt gefunden wurde.

    Der Parcour ist aber dann auch nicht lösbar, wenn einer der beiden Knotenmengen leer ist,
    dann kann nämlich bei allen weiteren Schritt der Breitensuche dieser Knotenmenge,
    keine weiteren Knoten erreicht werden und somit können beide Knotenmengen nie überlappen,
    da eine Knotenmenge ab jetzt immer leer ist.
    Es handelt sich also um eine Sackgasse im Parcour.

    So kommt es in \hyperref[fig:Figure2]{Figur 2.} zu einer solchen Sackgasse.

    \begin{figure}[htb]
        \centering
        \NewAdigraph{NameOfAdigraph}{
            1:0,0;
            2:4.5,0;
            3:1.5,0;
            4:3,0;
        }{
            1,3;
            3,4;
            2,4;
        }{}
        \NameOfAdigraph{}
        \caption{Nicht lösbarer Parcour mit Sackgasse}
        \label{fig:Figure2}
    \end{figure}

    \begin{table}[htb]
        \centering
        \begin{tabular}{lll}
            \textbf{Schritt} & \textbf{Spieler 1 Knotenmenge} & \textbf{Spieler 2 Knotenmenge} \\
            1.               & \{ 1 \}                        & \{ 2 \}                        \\
            2.               & \{ 3 \}                        & \{  \}                           \\
        \end{tabular}
        \caption{Schrittfolge für Figur 2.}
        \label{tab:Table2}
    \end{table}

    Denn hier kommt es bereits im zweiten Schritt dazu, dass die Knotenmenge des Spieler 2 leer ist.
    Damit ist es unmöglich das Spieler 1 und 2 sich je treffen, da Spieler 2 nicht mehr im Parcour ist.

    Beim Algorithmus muss also bei jedem Schritt der Breitensuche überprüft werden,
    ob die jetzige Knotenmenge von beiden Spielern sich
    zu einem gemeinsamen Zeitpunkt wiederholt.
    Dafür muss eine Liste an bisherigen Knotenmengen beider Spieler geführt werden.
    Es muss auch überprüft werden ob einer der beiden Knotenmengen leer ist.
    Ist einer dieser Bedingungen erfüllt, ist der Graph nicht lösbar
    und die Suche nach einem gemeinsamen Feld kann abgebrochen werden.
    Ansonsten kann überprüft werden,
    ob die beiden neuen Knotenmengen sich überschneiden,
    dann kann der Parcours an diesem Schritt an einem Feld
    von beiden Spielern gleichzeitig erreicht werden.
    Ist die Bedingung nicht erfüllt,
    folgt ein weiterer Schritt der Breitensuche.

    Wenn man aber nun einen Zeitpunkt gefunden hat,
    wo beide Knotenmengen sich überschneiden,
    muss ein Weg gefunden werden zu
    einer der überschneidenden Knoten in den Knotenmengen.
    Dafür kann jeder der überschneidenden Knoten ausgewählt werden.

    Nun hat man eine n lange Liste von Knotenmengen,
    wo der letzte Eintrag die überschneidende Knotenmenge ist
    und man hat einen ausgewählten überschneidenden Knoten in diesem letzten Eintrag.
    Jede Position in dieser Liste ist also ein Schritt
    und die Knotenmenge sind alle Knoten die erreichbar sind in nach diesem Schritt.
    Beim ersten Eintrag in der Liste,
    ist zudem zu beachten,
    dass die Knotenmenge nur aus dem Startknoten besteht.

    Auch der Weg ist eine n lange Liste,
    aber an einzelnen Knoten.
    Jeder Knoten an einer Position l muss enthalten sein
    in der Knotenmenge der gleichen Postion l der schon gegebenen Liste von Knotenmengen,
    da diese Knotenmenge alle Knoten enthält die nach dem Schritt l möglich zu erreichen sind.
    Gleichzeitig muss der Knoten der Position l eine Kante zum nächsten Knoten,
    d.h. Knoten der Position $l + 1$ besitzen,
    da sonst von den Knoten im Weg
    gar kein richtiger Weg zwischen den Knoten gebildet wird.
    Außerdem muss der letzte Knoten im Weg,
    der ausgewählte überschneidende Knoten sein.
    Da die erste Knotenmenge nur aus dem Startknoten besteht,
    ist auch der Knoten an der ersten Position immer nur der Startknoten,
    da der Weg auch immer vom Startknoten starten muss.

    Wenn man für eine Position i im Weg einen Knoten ermitteln möchte,
    muss man deswegen nur nach einem Knoten in der zugehörigen Knotenmenge suchen
    (also Knotenmenge der Knotenmengen Liste an Position i),
    die zur Position $i + 1$ führt.
    Da aber am Anfang nur der letzte Knoten an Position j ermittelt ist,
    kann von dem angefangen werden und der Knoten an Position $j - 1$ ermittelt werden,
    der zum Knoten an Position j führt.
    Dann kann $j - 2$, $j - 3$, usw. ermittelt werden,
    bis j die erste Position ist.


    \section{Umsetzung}\label{sec:umsetzung}
	% Beispiel graph
	Eine Menge von Knoten wird als \texttt{BitSet} dargestellt.
	Ein \texttt{BitSet} in Java ist eine Datenstruktur mit einer festen Anzahl von Bits,
	die alle anhand eines Indexes gesetzt werden können.
	Die Länge jedes \texttt{BitSet} ist gleich die Anzahl aller möglichen Knoten
	und jeder Index korrespondiert einem Knoten.
	Ist an diesen Index im \texttt{BitSet} eine 1,
	ist der Knoten in der Knotenmenge enthalten, ansonsten ist er es nicht.
	Beispielsweise gilt $0101 \widehat{=} \{2, 4\}$.
	Da der erste Index eines \texttt{BitSet} 0 ist,
	korrespondiert der Index 0 zu Knoten 1 des Parcours.
	
	Ein Graph wird als \texttt{BitSet[]} dargestellt, also ein Array von \texttt{BitSet}.
	Jeder Index des Arrays korrespondiert wieder zu einem Knoten (Index 0 zu Knoten 1, usw.).
	Der am Index eines Knotens A enthaltene \texttt{BitSet}, ist eine Knotenmenge,
	die enthält zu welchen Knoten der Knoten A (von Knoten A aus) eine Kante besitzt.
	
	Die Liste an Knotenmengen ist eine \texttt{List<BitSet>},
	d.h. eine \texttt{List} aus \texttt{BitSet}.
	Index 0 der \texttt{List} korrespondiert zur ersten Position der Liste von Knotenmengen.
	
	Ein Weg ist ein \texttt{int[]}, also ein Array an Integern,
	der Index 0 des Weges korrespondiert auch zur ersten Position des Weges.
	Ist am Index 2 beispielsweise der Integer 3 eingetragen,
	befindet sich an der dritten Position des Weges der Knoten 4.


    \section{Beispiele}\label{sec:beispiele}

    \begin{figure}[htb]
        \centering
        \NewAdigraph{IL}{
            1:0,0;
            2:1,1;
            3:0,2;
            4:2,2;
            5:3,2;
            6:4,1;
            7:3,0;
            8:2,0;
        }{
            1,2;
            2,3;
            3,1;
            2,4;
            4,5;
            5,6;
            6,7;
            7,8;
            8,2;
        }{}
        \IL{}
        \caption{Unendlcher Parcour}
        \label{fig:Figure3}
    \end{figure}

    \begin{figure}[htb]
        \centering
        \NewAdigraph{IL}{
            1:0,0;
            2:2,0;
            3:0,2;
            4:1,1;
            5:3,2;
            6:4,2;
            7:5,1;
            8:4,0;
            9:3,0;
        }{
            1,4;
            4,3;
            3,1;
            4,5;
            5,6;
            2,9;
            9,8;
            8,7;
            7,6;
        }{}
        \IL{}
        \caption{Sackgasse Parcour}
        \label{fig:Figure4}
    \end{figure}

    \begin{figure}[htb]
        \centering
        \NewAdigraph{InfLoop}{
            1:3,0;
            2:-3.5,-1;
            3:-1.5,0;
            4:4,0;
            5:0,3;
            6:-3.5,1;
            7:1.5,3;
            8:3.5,1.5;
            9:3,-1.5;
            10:0,0;
            11:0,-3;
            12:-1.5,1.5;
            13:0,1.5;
            14:1.5,0;
            15:-3,3;
            16:0,-1.5;
            17:2,-3;
            18:1.5,1.5;
            19:-2.5,-3;
            20:-1.5,-1.5;
        }{
            1,18:1;
            1,8;
            1,4;
            2,3;
            2,19:1;
            3,19;
            3,6;
            5,15;
            5,12;
            5,13;
            6,2;
            6,12;
            7,5;
            7,8;
            8,18;
            8,4;
            9,4;
            9,1;
            9,14;
            10,16;
            10,3;
            10,12;
            10,18;
            11,19;
            12,3;
            13,7;
            13,10:3;
            14,17;
            14,16;
            14,10;
            14,18;
            14,1;
            15,12;
            16,11;
            16,20;
            16,17;
            16,19;
            17,11;
            17,9;
            18,13:2;
            18,7;
            19,20:2;
            20,3;
            20,10:3;
        }
        \InfLoop{
            1,18,13,10::blue;
            2,19,20,10::red;
        }
        \caption{Beispiel1 Parcour}
        \label{fig:Figure5}
    \end{figure}


    \section{Quellcode}\label{sec:quellcode}\label{LastPage}
    \begin{lstlisting}[frame=single,language=Java,title=Methode graphFromLines,breaklines=true]
    /**
     * Generiert den Graphen aus den Zeilen einer Eingabedatei.
     *
     * @param lines Eine String Liste, wo jeder String eine Zeile im Eingabeformat ist.
     * @return Den generierten Graphen.
     */
    private static BitSet[] graphFromLines(List<String> lines) {
        int countOfNodes = Integer.parseInt(lines.get(0).split(" ")[0]);
        BitSet[] graph = new BitSet[countOfNodes];
        for (int i = 0; i < countOfNodes; i++) {
            graph[i] = new BitSet(countOfNodes);
        }
        List<String> rawArrows = lines.subList(1, lines.size());
        for (String rawArrow : rawArrows) {
            int arrowBegin = Integer.parseInt(rawArrow.split(" ")[0]);
            int arrowEnd = Integer.parseInt(rawArrow.split(" ")[1]);
            graph[arrowBegin - 1].set(arrowEnd - 1);
        }
        return graph;
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode sameTargetRoute,breaklines=true]
    /**
     * Findet eine Route, vom nullten und ersten Knoten,
     * zu einem gemeinsamen Knoten in einer gleichen Anzahl von Schritten.
     *
     * @param graph Der Graph, zu dem eine Route vom nullten und ersten Knoten zu einem gemeinsamen Knoten gebildet werden soll.
     * @return Eine Route zu einem Knoten der vom 0. und 1. Knoten in der gleichen Anzahl von Schritten erreichbar ist.
     */
    private static int[][] sameTargetRoute(BitSet[] graph) {
        BitSet sashaFirst = new BitSet(graph.length);
        BitSet mikaFirst = new BitSet(graph.length);
        sashaFirst.set(0);
        mikaFirst.set(1);
        List<BitSet> sashaTimeline = new ArrayList<>(List.of(sashaFirst));
        List<BitSet> mikaTimeline = new ArrayList<>(List.of(mikaFirst));
        do {
            sashaTimeline.add(neighbourNodes(sashaTimeline.get(sashaTimeline.size() - 1), graph));
            mikaTimeline.add(neighbourNodes(mikaTimeline.get(mikaTimeline.size() - 1), graph));
            if (sashaTimeline.get(sashaTimeline.size() - 1).isEmpty() || mikaTimeline
                    .get(mikaTimeline.size() - 1)
                    .isEmpty() || timelineRepeats(sashaTimeline, mikaTimeline)) {
                return null;
            }
        } while (!sashaTimeline.get(sashaTimeline.size() - 1).intersects(mikaTimeline.get(mikaTimeline.size() - 1)));

        int target = firstSameTargetOfTimelines(sashaTimeline, mikaTimeline);
        int[][] routes = new int[2][];
        routes[0] = findSingleRouteInTimeline(sashaTimeline, target, graph);
        routes[1] = findSingleRouteInTimeline(mikaTimeline, target, graph);
        return routes;
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode firstSameTargetOfTimelines,breaklines=true]
    /**
     * Vergleicht den jeweils letzten Schritt der Schrittfolgen miteinander
     * und gibt den gemeinsamen besuchten Knoten zurück.
     *
     * @param sashaTimeline Sasha's Zeitleiste
     * @param mikaTimeline  Mika's Zeitleiste
     * @return Der Index im Graphen des gemeinsamen Knotens.
     */
    private static int firstSameTargetOfTimelines(List<BitSet> sashaTimeline, List<BitSet> mikaTimeline) {
        BitSet targets = (BitSet) sashaTimeline.get(sashaTimeline.size() - 1).clone();
        targets.and(mikaTimeline.get(mikaTimeline.size() - 1));
        return targets.nextSetBit(0);
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode findSingleRouteInTimeline,breaklines=true]
    /**
     * Ermittelt den Weg vom Zielpunkt zurück zum Startpunkt entgegengesetzt der Kantenrichtung des Graphen.
     *
     * @param timeline Die Zeitleiste der erreichbaren Knoten,
     *                 von der eine Route zu einem bestimmten Knoten im letzten Zeitpunkt der Zeitleiste gebaut werden soll.
     * @param target   Das Ziel am Ende der Zeitleiste der erreichbaren Knoten, zudem eine Route gebaut werden soll.
     * @param graph    Der Graph aus dem die Zeitleiste der erreichbaren Knoten (und dementsprechend auch das Ziel) stammt.
     * @return Eine Route zum Ziel in der Zeitleiste.
     */
    private static int[] findSingleRouteInTimeline(List<BitSet> timeline, int target, BitSet[] graph) {
        int[] route = new int[timeline.size()];
        steps:
        for (int currentStep = timeline.size() - 1; currentStep > 0; currentStep--) {
            route[currentStep] = target;
            BitSet currentNodes = timeline.get(currentStep - 1);
            for (int i = 0; i < graph.length; i++) {
                if (currentNodes.get(i)) {
                    BitSet arrows = graph[i];
                    if (arrows.get(target)) {
                        target = i;
                        continue steps;
                    }
                }
            }
        }
        route[0] = target;
        return route;
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode neighbourNodes,breaklines=true]
    /**
     * Gibt die Knoten zurück, welche in einem Schritt entlang der Kantenrichtung,
     * von den aktuellen Knoten erreichbar sind.
     *
     * @param nodes Die aktuellen Knoten
     * @param graph Der Graph, welcher betrachtet wird
     * @return Die Menge der Knoten die in einem Schritt von den gegebenen Knoten erreichbar ist
     */
    private static BitSet neighbourNodes(BitSet nodes, BitSet[] graph) {
        BitSet neighbours = new BitSet();
        for (int i = 0; i < graph.length; i++) {
            if (nodes.get(i)) {
                neighbours.or(graph[i]);
            }
        }
        return neighbours;
    }
    \end{lstlisting}


    \begin{lstlisting}[frame=single,language=Java,title=Methode timelineRepeats,breaklines=true]
    /**
     * Ermittelt, ob die zwei Zeitleisten sich zu einem Zeitpunkt mit ihrem letzten Eintrag wiederholen.
     * Es wird daher festgestellt, ob beide Zeitleisten zu einem vorherigen Zeitpunkt an den genau gleichen Knoten waren,
     * wie zum aktuellen Zeitpunkt.
     *
     * @param sashaTimeline Sasha's Zeitleiste der erreichbaren Knoten
     * @param mikaTimeline  Mika's Zeitleiste der erreichbaren Knoten
     * @return True, wenn die Zeitleisten sich beide zu einem gleichen Zeitpunkt
     * mit dem neuen/letzten Zeitpunkt wiederholen.
     */
    private static boolean timelineRepeats(List<BitSet> sashaTimeline, List<BitSet> mikaTimeline) {
        BitSet current = sashaTimeline.get(sashaTimeline.size() - 1);
        BitSet repetitions = new BitSet(sashaTimeline.size());
        List<BitSet> timeline = new ArrayList<>(sashaTimeline.subList(0, sashaTimeline.size() - 1));
        for (int i = 0; i < timeline.size(); i++) {
            if (timeline.get(i).equals(current)) {
                repetitions.set(i);
            }
        }
        for (int i = repetitions.nextSetBit(0); i >= 0; i = repetitions.nextSetBit(i + 1)) {
            if (mikaTimeline.get(mikaTimeline.size() - 1).equals(mikaTimeline.get(i))) {
                return true;
            }
        }
        return false;
    }
    \end{lstlisting}


\end{document}
