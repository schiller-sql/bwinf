\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten vier Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 4: Fahrradwerkstatt}        % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeamId}{?????}                       % Team-ID aus dem PMS angeben
\newcommand{\TeamName}{????}                      % Team-Namen angeben
\newcommand{\Namen}{Tony Borchert}% Namen der Bearbeiter/-innen dieser Aufgabe angeben

% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Team-ID: \TeamId}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

% Für Algorithmen
\usepackage{algpseudocode}

% Für Quelltext
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
    keywordstyle=\color{blue},commentstyle=\color{mygreen},
    stringstyle=\color{mymauve},rulecolor=\color{black},
    basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
    captionpos=b, % sets the caption-position to bottom
    keepspaces=true, % keeps spaces in text
    numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
    showtabs=false, stepnumber=2, tabsize=2, title=\lstname ,
    inputencoding = utf8,  % Input encoding
    extendedchars = true,  % Extended ASCII
    literate      =        % Support additional characters
      {á}{{\'a}}1  {é}{{\'e}}1  {í}{{\'i}}1 {ó}{{\'o}}1  {ú}{{\'u}}1
      {Á}{{\'A}}1  {É}{{\'E}}1  {Í}{{\'I}}1 {Ó}{{\'O}}1  {Ú}{{\'U}}1
      {à}{{\`a}}1  {è}{{\`e}}1  {ì}{{\`i}}1 {ò}{{\`o}}1  {ù}{{\`u}}1
      {À}{{\`A}}1  {È}{{\'E}}1  {Ì}{{\`I}}1 {Ò}{{\`O}}1  {Ù}{{\`U}}1
      {ä}{{\"a}}1  {ë}{{\"e}}1  {ï}{{\"i}}1 {ö}{{\"o}}1  {ü}{{\"u}}1
      {Ä}{{\"A}}1  {Ë}{{\"E}}1  {Ï}{{\"I}}1 {Ö}{{\"O}}1  {Ü}{{\"U}}1
      {â}{{\^a}}1  {ê}{{\^e}}1  {î}{{\^i}}1 {ô}{{\^o}}1  {û}{{\^u}}1
      {Â}{{\^A}}1  {Ê}{{\^E}}1  {Î}{{\^I}}1 {Ô}{{\^O}}1  {Û}{{\^U}}1
      {œ}{{\oe}}1  {Œ}{{\OE}}1  {æ}{{\ae}}1 {Æ}{{\AE}}1  {ß}{{\ss}}1
      {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1  {Ø}{{\O}}1   {å}{{\r a}}1
      {Å}{{\r A}}1 {ã}{{\~a}}1  {õ}{{\~o}}1 {Ã}{{\~A}}1  {Õ}{{\~O}}1
      {ñ}{{\~n}}1  {Ñ}{{\~N}}1  {¿}{{?`}}1  {¡}{{!`}}1
      {°}{{\textdegree}}1 {º}{{\textordmasculine}}1 {ª}{{\textordfeminine}}1
}
\lstdefinelanguage{JavaScript}{ % JavaScript ist als einzige Sprache noch nicht vordefiniert
    keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with},
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]',
    morestring=[b]",
    sensitive=true
}

% Diese beiden Pakete müssen zuletzt geladen werden
\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Team-ID: \LARGE \TeamId \\\\
\LARGE Team-Name: \LARGE \TeamName \\\\
\LARGE Bearbeiter/-innen dieser Aufgabe: \\
\LARGE \Namen\\\\}
\date{\LARGE\today}

\begin{document}

\maketitle
\tableofcontents

\vspace{0.5cm}

\section{Teilaufgabe 2}\label{sec:begruendung2}
Es werden nicht alle Kunden zufrieden sein,
da die Aufträge nicht unbedingt in der Reihenfolge bearbeitet werden,
indem sie vergeben wurden.
Somit kann es dazu kommen, dass der Auftrag eines Kunden
erst nach einem später abgegebenen Auftrag bearbeitet wird.
Dies passiert wenn nachfolgende Aufträge kürzer sind,
als der vorangegangene Auftrag und vergeben wurden,
als Marc noch beschäftigt mit einem anderen Auftrag ist oder er gerade nicht arbeitet,
wenn also der längere Auftrag nicht nur alleine zur Bearbeitung zur Verfügung steht.
So kann es dazu kommen, dass der Autrag des ersten Kunden als letztes abgearbeitet wird.

\section{Teilaufgabe 3}\label{sec:begruendung3 }
Würde man in einem echten Geschäft bestimmte Kunden vorziehen,
würden sich die Kunden, welche nicht vorgezogen werden, verständlicherweise beschweren.
Da bei einem Vorziehen des einen Kunden immer Nachteile für die anderen Kunden bestehen.

In Ausnahmen könnte Marc entscheiden, dass ein ganz kurzer Auftrag vor einem ganz langen Auftrag geschoben wird,
da es die Wartezeit des langen Auftrages kaum vergrößert.
Besonders, wenn der lange Auftrag noch nicht viel warten musste.
Auch könnte Marc eine Ausnahmen machen, wenn es sich um einen Kunden handelt,
der entweder von Marc besonders geschätzt wird
oder aber eine Gebühr gibt für schnelleres reparieren gezahlt hat.
Da diese Informationen nicht dem Algorithmus vorliegenden,
können sie aber nicht in Betracht gezogen werden.
Wo aber die Grenze genau ist, ist arbiträr, mathematisch nicht belegt
und kann nicht algorithmisch dargestellt werden.
Deshalb ist das allererste Verfahren, vermutlich das beste algorithmische Verfahren,
da jeder fair an der Reihe ist,
in der Reihenfolge wann dessen Auftrag eingegangen ist.

\section{Lösungsidee}\label{sec:losungsidee}
Der Aufgabenstellung zu entnehmen,
ist das jeder Auftrag eine Dauer und einen Zeitpunkt besitzt.
Des weiteren werden die Aufträge in den Eingabedateien
nach dem Eingangszeitpunkt absteigend sortiert.
Die Aufträge dürfen aber immer nur im Zeitraum von 9 Uhr bis 17 Uhr
am Arbeitstag abgearbeitet werden.
Erst nachdem ein Auftrag vollständig bearbeitet wurde,
darf der nächste bearbeitet werden.

Obwohl es unterschiedliche Verfahren gibt,
wie der nächst zu bearbeitende Auftrag ausgewählt wird,
kann trotzdem ein verfahrensunabhängiger Algorithmus
die Auswahl des nächsten Auftrages delegieren
und sich selber mit der Simulation der Fahrradwerkstatt beschäftigen.
Der Auftrag, welcher als nächstes bearbeitet werden soll,
muss ein bereits eingeganener Auftrag sein.
Gibt es einen solchen nicht, muss gewartet werden.
Dies gilt unabgängig vom Verfahren,
welches zur Bewältigung der Aufträge angewendet wird.
Daher eignet sich zunächst
die Betrachtung eines verfahrensunabhängigem Algorithmus.

Als erstes wird sich die aktuelle Zeit
und das Ende des jetzigen Arbeitstages gemerkt.
Dazu die maximale und gesamte Wartezeit,
als auch die eingegangenen (aber nicht bearbeiteten) und noch eingehenden Aufträge.
Am Anfang ist die aktuelle Zeit 9 Uhr
und das Ende des Arbeitstages ist um 17 Uhr.

Es bietet sich an, den Tagesablauf wie folgt zu simulieren.
\begin{algorithmic}
\While{$es$ $unbearbeitete$ $Auftraege$ $gibt$}
\State $waehle$ $einen$ $Auftrag$ $nach$ $dem$ $aktuell$ $ausgewaehlten$ $Verfahren$
\While{$der$ $Auftrag$ $noch$ $nicht$ $abgearbeitet$ $ist$}
\State $bearbeite$ $den$ $Auftrag$
\If{$der$ $Areitstag$ $zu$ $Ende$ $ist$}
\State $gehe$ $zum$ $Morgen$ $des$ $naechsten$ $Tages$
\State $fuehre$ $den$ $Auftrag$ $fohrt$
\EndIf
\EndWhile
\State $erhoehe$ $die$ $Zeit$ $um$ $die$ $Bearbeitungsdauer$ $des$ $Auftrages$
\If{$kein$ $Auftrag$ $vorliegt$}
\State $warte$ $auf$ $den$ $naechsten$ $Auftrag$
\State $setze$ $beim$ $eingehen$ $des$ $Auftrages$ $die$ $aktuelle$ $Zeit$ $auf$ $die$ $Zeit$ $des$ $Eingehens$
\EndIf
\EndWhile
\end{algorithmic}


Nun wird in einer Schleife, bis es keine eingegangenen und noch nicht eingegangenen Aufträge gibt, folgendes gemacht:
\begin{itemize}
	\item Alle Aufträge die im Container der noch nicht eingegangenen Aufträge sind,
	      aber schon eingegangen sind laut aktueller Zeit,
    werden von den nicht eingegangenen zu den eingegangenen Containern bewegt.
	\item Gibt es eingegangene Aufträge:
	      \begin{itemize}
		      \item Von den eingegangenen Aufträgen wird nach dem aktuellen Verfahren
		            zur Bestimmung des nächst zu bearbeitenden Auftrages, ein Auftrag bestimmt.
		      \item Es wird sich der Fortschritt des Auftrages in Zeit gemerkt, also am Anfang 0.
		      \item In einer Schleife bis der Auftrag fertig bearbeitet ist:
		            \begin{itemize}
			            \item Wenn die Zeit am gemerkten Ende des jetzigen Arbeitstages ist,
                        wird die Zeit zum nächsten Tag um 9 Uhr gestellt,
			                  also dem beginn des nächsten Arbeitstages und
			                  es wird sich nun das Ende des nächsten Arbeitstages gemerkt,
                        also am nächsten Tag um 17 Uhr.
			                  D.h. die Simulation befindet vorher am Ende eines Arbeitstages
                        und sich jetzt am nächsten Arbeitstag
			                  und weiß wann dort das Ende dieses Arbeitstages ist.
			            \item Anhand der Differenz zwischen der momentanen Zeit
                        und des gemerkten Endes dieses Arbeitstages,
			                  kann ermittelt werden wie viel Zeit noch in in diesem Arbeitstag verbleibt.
			            \item Anhand der Differenz zwischen dem Fortschritt des Auftrages
			                  und der Dauer des Auftrages, kann ermittelt werden
                        wie viel Zeit noch vom Auftrag übrig bleibt.
			            \item Das kürzere der beiden, also entweder Verbleib des Arbeitstages
                         oder Verbleib des Auftrages,
			                  wird gewählt und an die Zeit und an dem Fortschritt des Auftrages addiert.
			            \item So befindet man sich zeitlich nun am Ende des Auftrages, am Ende des Arbeitstages
			                  oder in einem Sonderfall, beidem. Befindet man sich am Ende des Auftrages (oder beidem),
			                  wird die Schleife nun abgebrochen, da die verbleibende Zeit zum Fortschritt addiert wurde
			                  und der Fortschritt so vollständig ist, was die Abbruchbedingung der Schleife ist.
			                  Falls man sich aber nur am Ende des Tages befindet,
			                  wird am Anfang des nächsten Durchlaufs der Schleife,
			                  zeitlich zum nächsten Tag gesprungen und der Auftrag wird weiter bearbeitet.
		            \end{itemize}
		      \item Nun ist die aktuelle Zeit genau am Zeitpunkt der Fertigstellung des Auftrages.
		      \item Durch die Differenz der aktuellen Zeit und des Eingangszeitpunktes des bearbeiteten Auftrages,
		            lässt sich die Wartezeit für diesen Auftrag ermitteln.
		            Die gesamte Wartezeit kann dementsprechend mit dieser Wartezeit addiert werden
		            und das Maximum der Wartezeit kann mit dieser Wartezeit ersetzt werden,
               wenn sie größer ist als das bisherige Maximum.
		      \item Da man sich genau an dem Zeitpunkt der Fertigstellung des Auftrages nun befindet,
		            bleibt der Sonderfall zu beachten: Wenn der Auftrag genau dann fertiggestellt ist,
		            wo der Arbeitstag endet, ist die aktuelle Zeit noch am Ende dieses Arbeitstages,
		            obwohl man eigentlich beim nächsten Durchlauf in der äußeren Schleife,
		            schon wieder am nächsten Tag um 9 Uhr sein möchte
               und sich merken möchte wann der nächste Arbeitstag endet.
		            Das muss sein, weil zwischen den beiden Arbeitstagen können neue Aufträge eingehen
		            und manche Verfahren zur Auswahl des nächsten Auftrages
		            wollen möglicherweise zwischen allen eingegangen Aufträgen wählen.
		      \item Deswegen wird nochmal falls die Zeit am gemerkten Ende des jetzigen Arbeitstages ist,
		            die Zeit zum Beginn des nächsten Arbeitstages gestellt
               und sich das Ende das nächsten Arbeitstages gemerkt.
	      \end{itemize}
	\item Gibt es keine eingegangen Aufträge, muss gewartet werden,
    bis zur Eingangszeit des nächsten Auftrages:
	      \begin{itemize}
		      \item Dafür wird in einer Schleife bis die aktuelle Zeit größer gleich der Eingangszeit des nächsten Auftrages ist:
		            \begin{itemize}
			            \item Die aktuelle Zeit gleich der Eingangszeit des nächsten Auftrages gesetzt.
			            \item Ist die aktuelle Zeit jetzt nach dem gemerkten Ende des Arbeitstages,
			                  wird die aktuelle Zeit auf dem Anfang das nächsten Tages nach dem gemerkten Ende des Arbeitstages gesetzt.
			                  Und das Ende das Arbeitstag wird sich als das Ende des nächsten Arbeitstages gemerkt.
		            \end{itemize}
		      \item Nun ist man im ersten Zeitpunkt, wo min. ein neuer Auftrag eingeht.
		      \item Der Sonderfall, das dieser Zeitpunkt genau am Ende eines Arbeitstages ist,
		            ist aber nicht möglich, da die Zeit zum neuen Arbeitstag in der Schleife am Ende verschoben wird.
	      \end{itemize}
\end{itemize}
Nun kann anhand der gesamten Wartezeit geteilt durch die Anzahl der Aufträge,
der Durchschnitt ermittelt werden
und für die maximale Wartezeit, das schon gemerkte Maximum genommen werden.

Was bei der Delegation des Verfahrens zur Bestimmung des nächsten Auftrages beachtet werden muss,
ist das wenn in der äußeren Schleife ein neuer Auftrag in den Container
der eingegangenen Aufträge bewegt wird,
dieser einsortiert wird. Das heißt das der Container der eingegangen Aufträge sortiert ist
und zwar Verfahrens abhängig,
da das einsortieren auch an das Verfahren delegiert wird.

Was also unterschiedlich bei den Verfahren sein kann, ist wie ein neu eingegangener Auftrag
in den schon eingegangenen Aufträgen einsortiert wird
und wie von den schon eingegangenen Aufträgen ein zu bearbeitender Auftrag ermittelt wird.

Die beiden Verfahren der Bestimmung des nächst zu bearbeitenden Auftrages wählen immer den ersten Auftrag
aus dem sortierten Container der eingegangenen Aufträge.
Sie sortieren jedoch die Aufträge unterschiedlich.
Das ursprüngliche Verfahren hängt einfach immer nur den neusten eingegangen Auftrag
in den Container der schon eingegangenen Aufträge hinten ein.
Da beim Auswählen des zu bearbeitenden Auftrages das erste ausgewählt wird,
ist dies das was von den eingegangen Aufträgen als erstes eingegangen ist
und werden damit in der Reihenfolge ihres Eingangs, wie Marc es plant, ausgewählt.
Das neue Verfahren sortiert neue eingehende Aufträge nach Dauer ein,
so dass das erste immer der Auftrag mit der geringsten Dauer ist.


\section{Umsetzung}\label{sec:umsetzung}
	Die Zeit beziehungsweise Auftragsdauer wird als Integer in Minuten dargestellt,
	 während die Zeitpunkte als Zeit von 0 Uhr aus gesetzt werden.
	Ein Auftrag wird dabei als Klassenobjekt \texttt{Task} mit Dauer und Eingangszeitpunkt modelliert.
	Wenn der gemerkte Zeitpunkt für das Ende des aktuellen Arbeitstages (17 Uhr),
	zum Ende des nächsten Arbeitstages (17 Uhr am nächsten Tag)  werden soll,
	muss der Zeitpunkt lediglich mit 24 Stunden ($24 * 60$ Minuten) addiert werden.
	Wenn die aktuelle Zeit gleich dem Ende des jetzigen Arbeitstages ist (17 Uhr)
	und auf den Anfang des nächsten Arbeitstages (nächsten Tag 9 Uhr) gestellt werden soll,
	muss die Zeit mit $(24 - 17) + 9 = 16$ Stunden ($16 * 60$ Minuten) addiert werden 
	Wenn die Zeit größer als das gemerkten Ende des Arbeitstages ist,
	man aber die Zeit nur auf dem Anfang des Arbeitstages nach den gemerkten Ende das Arbeitstages setzten möchte,
	muss man die Zeit gleich des jetzigen gemerkten Ende des Arbeitstages + 9 setzen.
	Die nicht eingegangenen Aufträge werden dargestellt als eine Liste von allen Aufträgen,
	      wo jedoch sich gemerkt wird, welche Aufträge noch nicht waren.
	      Da alle Aufträge sortiert sind, nach Eingangszeitpunkt, wird sich konkret nur der Index gemerkt,
	      wo der zugehörige Auftrag der erste Auftrag ist, der sich noch nicht in den eingegangen Aufträgen befindet.
	Deswegen, in der äußeren Schleife, wird auch, wenn alle Aufträge die sich noch nicht
	      in den eingegangenen Aufträgen befinden, sich dort aber laut der Zeit sich befinden sollten,
	      lediglich der Index des ersten Auftrages, der sich nicht mehr in den eingegangen Aufträgen befindet,
	      erhöht, bis der Auftrag mit dem Index eine höhere Eingangszeit hat als was die momentane Zeit ist.
	      D.h. wenn dieser Auftrag nach der aktuellen Zeit noch nicht eingegangen ist.
	Die schon eingegangenen Aufträge werden dargestellt als sortierte Liste von Aufträgen,
	      die nur die Aufträge enthält, die auch schon eingegangen sind.
	Die Delegation der Bestimmung des nächst zu bearbeitenden Auftrages erfolgt
	      durch eine abstrakte Klasse \texttt{TaskPriorityDelegate}.
	      An einem Objekt einer Unterklasse dieser abstrakten Klassen wird
	      also das Auswählen des nächsten Auftrages delegiert.
	      Jedes Verfahren des Auswählen des nächsten Auftrages wird
	      also als eine Unterklasse dieser abstrakten Klasse dargestellt.
	Die abstrakte Klasse hat zwei Methoden, die sich jeweils um das Sortieren
	      der neu eingegangenen Aufträge in die schon eingegangen Aufträge
	      und um das Auswählen der schon sortierten eingegangen Aufträge kümmern.
	      Bei der sortierenden Methode, wird die Liste an schon eingegangenen Aufträgen gegeben
	      und ein gegebener Auftrag soll dort einsortiert werden.
	      Bei der auswählenden Methode wird auch die Liste an schon eingegangenen Aufträgen gegeben
	      und es muss ein Auftrag daraus entfernt werden und zurückgegeben werden.
	Da beide Verfahren und damit Implementationen der Klasse immer den ersten Auftrag auswählen
	      und sich nur in der Sortierung unterscheiden ist die Auswahl des Auftrages schon implementiert in der abstrakten Klasse
	      und muss nicht mehr in den Unterklassen unterschieden. Da aber andere Verfahren möglich sind,
	      die entweder nicht sortieren oder die Sortierung nur teilweise berücksichtigen, gibt es diese Methode trotzdem.
	Die Klasse \texttt{FiFoTaskPriorityDelegate} implementiert \texttt{TaskPriorityDelegate}
	      nach der Reihenfolge der eingehenden Aufträge.
	Die Klasse \texttt{ShortestDurationTaskPriorityDelegate} implementiert \texttt{TaskPriorityDelegate}
	      nach der aufsteigenden Dauer der eingehenden Aufträge.
	In der Methode \texttt{simulateProcessingTasks} wird die Abarbeitung von den Aufträgen simuliert.
	      Es wird ein \texttt{TaskPriorityDelegate} gegeben und eine Liste von Aufträgen.
	      Ausgegeben wird dann die durchschnittliche, längste und gesamte Wartezeit.
	Die Methode \texttt{simulateProcessingTasks} wird deshalb in der \texttt{main} Methode
	      mit jeder Kombination von jedem \texttt{TaskPriorityDelegate} und jeder Eingabedatei aufgerufen.
	      Alle Unterklassen vom \texttt{TaskPriorityDelegate} sind als Array
	      in der Konstante \texttt{taskPriorityDelegates} eingetragen.

\section{Beispiele}\label{sec:beispiele}


\section{Quellcode}\label{sec:quellcode}\label{LastPage}
\begin{lstlisting}[frame=single,language=Java,title=Klasse Task,breaklines=true]
	/**
     * Ein Auftrag
     *
     * @param entranceTime Der Eingangszeitpunkt des Auftrages in Minuten von t0
     * @param duration     Die Dauer des Auftrages in Minuten
     */
    private record Task(int entranceTime, int duration) {
    }
	\end{lstlisting}
\begin{lstlisting}[frame=single,language=Java,title=Klasse TaskPriorityDelegate,breaklines=true]
	/**
     * Eine Klasse die entscheidet in welcher Reihenfolge die eingehenden Aufträge verwaltet werden sollen.
     */
    abstract private static class TaskPriorityDelegate {
        /**
         * @return Der Name dieses Verfahrens, in welcher Reihenfolge die eingehenden Aufträge verwaltet werden sollen.
         */
        public abstract String getName();

        /**
         * Wo in der aktuellen Liste der schon eingegangen Aufträge ein neuer Auftrag eingehen soll.
         * Das hat aber keinen direkten Einfluss darauf, wann dieser neue Auftrag angenommen werden soll,
         * denn pickTask entscheidet dass.
         * Durch eine Sortierung der Liste durch sortTaskIntoCurrentTaskList
         * kann aber pickTask oft effizienter vorgehen.
         * <p>
         * Die implementierte Methode soll also an einer stellte in der taskQueue den newTask einsortieren.
         *
         * @param taskQueue Die aktuelle Liste der eingegangenen Aufträge
         * @param newTask   Der neue Auftrag, der in die Liste, der eingegangen Aufträge eingenommen werden soll.
         */
        public abstract void sortTaskIntoCurrentTaskList(List<Task> taskQueue, Task newTask);

        /**
         * Wählt den nächsten Auftrag zum Bearbeiten von der Liste der schon eingegangen Aufträge aus,
         * entfernt ihn aus dieser Liste und gibt ihn zurück.
         * Durch Sortieren dieser Liste in sortTaskIntoCurrentTaskList ist ein effizienteres Auswählen möglich.
         * <p>
         * Standardmäßig nimmt, wählt die Methode den ersten Auftrag in der Liste aus, da davon ausgegangen wird,
         * dass meistens die Liste in sortTaskIntoCurrentTaskList sortiert wird.
         *
         * @param taskQueue Die Liste der eingegangenen Aufträge.
         * @return Der Auftrag, der als nächstes bearbeitet werden soll.
         */
        public Task pickTask(List<Task> taskQueue) {
            return taskQueue.remove(0);
        }
    }
	\end{lstlisting}
\begin{lstlisting}[frame=single,language=Java,title=Klasse FiFoTaskPriorityDelegate,breaklines=true]
    /**
     * Eine Implementation von {@link TaskPriorityDelegate}, die immer den Auftrag der als neuestes eingegangen ist,
     * als letztes bearbeitet.
     */
    static class FiFoTaskPriorityDelegate extends TaskPriorityDelegate {
        @Override
        public String getName() {
            return "Auftrag Reihenfolge priorisieren";
        }

        /**
         * Sortiert immer den neuen Auftrag immer ganz hinten. Da wenn der Auftrag in pickTask ausgewählt wird,
         * immer der erste genommen wird, wird damit der älteste ausgewählt.
         */
        @Override
        public void sortTaskIntoCurrentTaskList(List<Task> taskQueue, Task newTask) {
            taskQueue.add(newTask);
        }
    }
	\end{lstlisting}
\begin{lstlisting}[frame=single,language=Java,title=Klasse ShortestDurationTaskPriorityDelegate,breaklines=true]
	/**
     * Eine Implementation von {@link TaskPriorityDelegate}, der immer den Auftrag als nächstes bearbeitet,
     * der am kürzesten dauert.
     */
    static class ShortestDurationTaskPriorityDelegate extends TaskPriorityDelegate {
        @Override
        public String getName() {
            return "Kürzester Auftrag priorisieren";
        }

        /**
         * Sortiert den neuen Auftrag in die Liste, der eingegangen Aufträge, ein, nach absteigender Dauer.
         * Da wenn der Auftrag in pickTask ausgewählt wird, immer der kürzeste genommen wird.
         */
        @Override
        public void sortTaskIntoCurrentTaskList(List<Task> taskQueue, Task newTask) {
            for (int i = 0; i < taskQueue.size(); i++) {
                if (taskQueue.get(i).duration > newTask.duration) {
                    taskQueue.add(i, newTask);
                    return;
                }
            }
            taskQueue.add(newTask);
        }
    }
	\end{lstlisting}
\begin{lstlisting}[frame=single,language=Java,title=Konstante taskPriorityDelegates,breaklines=true]
	/**
     * Alle Verfahren zur Auswahl des nächst zu bearbeitenden Auftrages.
     */
     private static final TaskPriorityDelegate[] taskPriorityDelegates = new TaskPriorityDelegate[]{
            new FiFoTaskPriorityDelegate(),
            new ShortestDurationTaskPriorityDelegate(),
    	};
	\end{lstlisting}
\begin{lstlisting}[frame=single,language=Java,title=Methode simulateProcessingTasks,breaklines=true]
	/**
     * Für alle Eingabedateien werden alle Verfahren durchgeführt
     * mit {@link Main#simulateProcessingTasks(List, TaskPriorityDelegate)}.
     */
	private static void simulateProcessingTasks(List<Task> tasks, TaskPriorityDelegate taskPriorityDelegate) {
        int maxWaitedTime = 0;
        int allWaitingTime = 0;
        int time = 9 * 60;
        int nextBreak = 17 * 60;
        int firstTaskNotOnTaskQueue = 0;
        List<Task> taskQueue = new ArrayList<>(tasks.size());
        while (firstTaskNotOnTaskQueue != tasks.size() || !taskQueue.isEmpty()) {
            while (firstTaskNotOnTaskQueue != tasks.size() && tasks.get(firstTaskNotOnTaskQueue).entranceTime <= time) {
                taskPriorityDelegate.sortTaskIntoCurrentTaskList(taskQueue, tasks.get(firstTaskNotOnTaskQueue));
                firstTaskNotOnTaskQueue++;
            }
            if (!taskQueue.isEmpty()) {
                Task currentlyExecutingTask = taskPriorityDelegate.pickTask(taskQueue);
                int currentlyExecutingTaskProgress = 0;
                while (currentlyExecutingTaskProgress != currentlyExecutingTask.duration) {
                    assert currentlyExecutingTaskProgress < currentlyExecutingTask.duration;
                    assert time <= nextBreak;
                    if (time == nextBreak) {
                        time += (9 + (24 - 17)) * 60;
                        nextBreak += 24 * 60;
                    }
                    int passedTime = currentlyExecutingTask.duration - currentlyExecutingTaskProgress;
                    if (time + passedTime > nextBreak) {
                        passedTime = nextBreak - time;
                    }
                    time += passedTime;
                    currentlyExecutingTaskProgress += passedTime;
                }
                int waitedTime = time - currentlyExecutingTask.entranceTime;
                allWaitingTime += waitedTime;
                maxWaitedTime = Math.max(waitedTime, maxWaitedTime);
                if (time == nextBreak) {
                    time += (9 + (24 - 17)) * 60;
                    nextBreak += 24 * 60;
                }
            } else {
                int targetedTime = tasks.get(firstTaskNotOnTaskQueue).entranceTime;
                while (time < targetedTime) {
                    time = targetedTime;
                    if (time >= nextBreak) {
                        time = nextBreak + 9;
                        nextBreak += 24 * 60;
                    }
                }
            }
        }
        double averageTaskProcessingTime = (double) allWaitingTime / (double) tasks.size();
        averageTaskProcessingTime = ((double) Math.round(averageTaskProcessingTime * 10)) / 10;

        System.out.println("Durchschnittliche Wartezeit pro Auftrag: " + averageTaskProcessingTime + " minuten");
        System.out.println("Gesamte Wartezeit für alle Aufträge: " + allWaitingTime + " minuten");
        System.out.println("Längste Wartezeit in allen Aufträgen: " + maxWaitedTime + " minuten");
    }
	\end{lstlisting}
\end{document}
